<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcript Merger - Fix DaVinci Resolve Speaker Detection | Merge & Edit Transcripts</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="The missing tool for DaVinci Resolve transcripts. Bypass unreliable speaker detection by recording speakers to separate tracks, transcribing individually, then merging with correct labels. Edit text, fix timings, sequence multi-part videos. 100% private - runs in browser.">
    <meta name="keywords" content="DaVinci Resolve transcripts, transcript merger, fix speaker detection, merge speaker tracks, subtitle editor, combine transcripts, sequence subtitles, podcast transcription, interview transcription, multi-speaker transcript">
    <meta name="author" content="Force Quit Productions">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://transcript-merger.pages.dev/">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://transcript-merger.pages.dev/">
    <meta property="og:title" content="Transcript Merger - Fix DaVinci Resolve Speaker Detection">
    <meta property="og:description" content="The missing tool for DaVinci Resolve transcripts. Bypass bad speaker detection by merging separately recorded speaker tracks with correct labels. Free & private.">
    <meta property="og:image" content="https://transcript-merger.pages.dev/favicon.svg">
    <meta property="og:site_name" content="Force Quit Productions">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://transcript-merger.pages.dev/">
    <meta name="twitter:title" content="Transcript Merger - Fix DaVinci Resolve Speaker Detection">
    <meta name="twitter:description" content="The missing tool for DaVinci Resolve transcripts. Merge separate speaker tracks with correct labels. Free & private.">
    <meta name="twitter:image" content="https://transcript-merger.pages.dev/favicon.svg">
    <meta name="twitter:creator" content="@force92000">
    
    <!-- Structured Data / JSON-LD -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Transcript Merger",
        "description": "The missing tool for DaVinci Resolve transcripts. Bypass unreliable speaker detection by recording speakers to separate tracks, transcribing individually, then merging with correct labels.",
        "url": "https://transcript-merger.pages.dev/",
        "applicationCategory": "Multimedia",
        "operatingSystem": "Any",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "featureList": [
            "Merge multiple SRT subtitle files",
            "Edit subtitle text and timings",
            "Add closed caption indicators",
            "Sequence multi-part subtitles",
            "Export to SRT, CSV, or JSON",
            "Works offline - no uploads required"
        ],
        "author": {
            "@type": "Organization",
            "name": "Force Quit Productions",
            "url": "https://forcequitproductions.com/"
        },
        "browserRequirements": "Requires JavaScript",
        "softwareVersion": "1.0"
    }
    </script>
    
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lucide/latest/umd/lucide.min.js"></script>
    <script src="https://gumroad.com/js/gumroad.js"></script>
    <style>
        [data-icon] {
            display: inline-block;
            width: 1em;
            height: 1em;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
            stroke: currentColor;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        .drag-active {
            border-color: #6366f1 !important; /* Indigo-500 */
            background-color: #1e293b !important; /* Slate-800 */
        }
        
        /* Dialogue Entry Editing Styles */
        .dialogue-entry {
            position: relative;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .dialogue-entry:hover:not(.selected) {
            border-color: #475569 !important;
        }
        .dialogue-entry.selected {
            border-color: #6366f1 !important;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        
        /* Edit Action Buttons */
        .edit-actions-top {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        .edit-actions-bottom {
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        .edit-actions-left,
        .edit-actions-center,
        .edit-actions-right {
            display: flex;
            gap: 0.5rem;
            flex: 1;
        }
        .edit-actions-left {
            justify-content: flex-start;
        }
        .edit-actions-center {
            justify-content: center;
        }
        .edit-actions-right {
            justify-content: flex-end;
        }
        .dialogue-entry.selected .edit-actions-top,
        .dialogue-entry.selected .edit-actions-bottom {
            opacity: 1;
            max-height: 50px;
            padding-top: 0.5rem;
        }
        .dialogue-entry.selected .edit-actions-top {
            padding-bottom: 0.5rem;
        }
        
        .edit-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.15s ease;
            border: none;
            cursor: pointer;
        }
        .edit-btn-add {
            background: #334155;
            color: #94a3b8;
        }
        .edit-btn-add:hover {
            background: #475569;
            color: #e2e8f0;
        }
        .edit-btn-save {
            background: #166534;
            color: #86efac;
        }
        .edit-btn-save:hover {
            background: #15803d;
            color: #bbf7d0;
        }
        .edit-btn-delete {
            background: #7f1d1d;
            color: #fca5a5;
        }
        .edit-btn-delete:hover {
            background: #991b1b;
            color: #fecaca;
        }
        .edit-btn-cc {
            background: #1e3a5f;
            color: #7dd3fc;
            font-size: 10px;
            width: auto;
            padding: 0 8px;
        }
        .edit-btn-cc:hover {
            background: #1e40af;
            color: #93c5fd;
        }
        
        /* Speaker Dropdown */
        .speaker-name-container {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        .speaker-name-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.875rem;
            color: #818cf8;
            padding: 4px 0;
            border-radius: 4px;
            transition: all 0.15s ease;
        }
        /* Only show hover/selected background when in edit mode */
        .dialogue-entry.selected .speaker-name-btn {
            background: #334155;
            padding: 4px 10px;
        }
        .dialogue-entry.selected .speaker-name-btn:hover {
            background: #475569;
        }
        /* Fix alignment during edit mode - keep speaker aligned to top */
        .dialogue-entry.selected .entry-content > div:first-child {
            align-items: flex-start;
        }
        .dialogue-entry.selected .speaker-name-container {
            margin-top: 0;
        }
        .speaker-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 180px;
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            z-index: 100;
            overflow: hidden;
            margin-top: 4px;
        }
        .speaker-option {
            padding: 10px 14px;
            cursor: pointer;
            color: #e2e8f0;
            font-size: 0.875rem;
            transition: background 0.1s ease;
        }
        .speaker-option:hover {
            background: #334155;
        }
        .speaker-option.selected {
            background: #4f46e5;
            color: white;
        }
        .speaker-option.custom-option {
            border-top: 1px solid #475569;
            color: #a5b4fc;
        }
        .speaker-option.rename-option {
            border-top: 1px solid #475569;
            color: #a78bfa;
            font-style: italic;
        }
        .speaker-option.rename-option:hover {
            background: #2e1065;
        }
        .speaker-custom-input {
            width: 100%;
            padding: 10px 14px;
            background: #0f172a;
            border: none;
            border-top: 1px solid #475569;
            color: #e2e8f0;
            font-size: 0.875rem;
            outline: none;
        }
        .speaker-custom-input::placeholder {
            color: #64748b;
        }
        
        /* Editable Text Area */
        .edit-text-input {
            width: 100%;
            min-height: 60px;
            padding: 8px 10px;
            background: #0f172a;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 0.875rem;
            line-height: 1.4;
            resize: vertical;
            outline: none;
            transition: border-color 0.15s ease;
        }
        .edit-text-input:focus {
            border-color: #6366f1;
        }
        
        /* Editable Timing */
        .timing-container {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .edit-timing-input {
            width: 100px;
            padding: 4px 6px;
            background: #0f172a;
            border: 1px solid #475569;
            border-radius: 4px;
            color: #94a3b8;
            font-size: 0.75rem;
            font-family: monospace;
            text-align: center;
            outline: none;
        }
        .edit-timing-input:focus {
            border-color: #6366f1;
            color: #e2e8f0;
        }
        .edit-timing-input.invalid {
            border-color: #ef4444 !important;
            color: #fca5a5;
            background: #450a0a;
        }
        .timing-separator {
            color: #64748b;
            font-size: 0.75rem;
        }
        .timing-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .timing-format-label {
            font-size: 0.6rem;
            color: #64748b;
            font-family: monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Dialogue text display (non-edit mode) */
        .dialogue-text-display {
            color: #cbd5e1;
            font-size: 0.875rem;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        
        /* CC Entry Indicator */
        .cc-indicator {
            display: inline-block;
            background: #1e3a5f;
            color: #7dd3fc;
            padding: 1px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 6px;
        }
        
        /* Custom Checkbox Styling - Cross-browser compatible */
        input[type="checkbox"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            min-width: 16px;
            min-height: 16px;
            border: 2px solid #64748b;
            border-radius: 4px;
            background-color: #1e293b;
            cursor: pointer;
            transition: all 0.15s ease;
            vertical-align: middle;
        }
        input[type="checkbox"]:hover {
            border-color: #818cf8;
        }
        input[type="checkbox"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4);
        }
        input[type="checkbox"]:checked {
            background-color: #6366f1;
            border-color: #6366f1;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='white' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round' d='M4 8l3 3 5-6'/%3E%3C/svg%3E");
            background-size: 12px 12px;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        /* Part Separator Styling for Sequencer Mode */
        .part-separator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 1.5rem 0;
            margin: 1rem 0;
        }
        .part-separator::before,
        .part-separator::after {
            content: '';
            flex: 1;
            height: 3px;
            background: linear-gradient(90deg, transparent, #6366f1, transparent);
        }
        .part-separator-label {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            font-weight: 700;
            font-size: 0.875rem;
            padding: 0.5rem 1.25rem;
            border-radius: 9999px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4);
        }
        
        /* Framerate Warning Banner */
        .framerate-warning {
            background: #78350f;
            border: 1px solid #f59e0b;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            animation: slideDown 0.3s ease-out;
        }
        .framerate-warning-icon {
            color: #fbbf24;
            flex-shrink: 0;
            display: flex;
            align-items: center;
        }
        .framerate-warning-text {
            color: #fef3c7;
            font-size: 0.875rem;
        }
        .framerate-warning-text strong {
            color: #fbbf24;
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Framerate Mismatch Highlight */
        .framerate-mismatch .framerate-select {
            border-color: #f59e0b !important;
            box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.3);
        }
        
        /* Social Links & About Button */
        .social-link {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: #334155;
            color: #94a3b8;
            transition: all 0.2s ease;
        }
        .social-link:hover {
            background: #475569;
            color: #f8fafc;
            transform: translateY(-2px);
        }
        .social-link svg {
            width: 18px;
            height: 18px;
        }
        .about-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: #334155;
            color: #94a3b8;
            font-weight: 600;
            font-size: 0.875rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .about-btn:hover {
            background: #475569;
            color: #f8fafc;
            transform: translateY(-2px);
        }
        .about-btn svg {
            width: 16px;
            height: 16px;
        }
        
        /* Support/Donate Button - Footer (compact) */
        .support-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, #ec4899, #f43f5e);
            color: white !important;
            font-weight: 600;
            font-size: 0.875rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none !important;
        }
        .support-btn:hover {
            background: linear-gradient(135deg, #db2777, #e11d48);
            transform: translateY(-2px);
            text-decoration: none !important;
        }
        
        /* Support/Donate Button - Modal (larger, prominent) */
        .support-btn-modal {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #ec4899, #f43f5e);
            color: white !important;
            font-weight: 600;
            font-size: 1rem;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none !important;
            box-shadow: 0 4px 14px rgba(236, 72, 153, 0.4);
        }
        .support-btn-modal:hover {
            background: linear-gradient(135deg, #db2777, #e11d48);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(236, 72, 153, 0.5);
            text-decoration: none !important;
        }
        
        /* Override Gumroad default button styles */
        .gumroad-button {
            background: none !important;
            box-shadow: none !important;
            border: none !important;
            outline: none !important;
        }
        
        /* Site Footer */
        .site-footer {
            margin-top: 2rem;
            padding: 1.5rem;
            background: #1e293b;
            border-top: 1px solid #334155;
            border-radius: 0.75rem;
            text-align: center;
        }
        .site-footer p {
            color: #64748b;
            font-size: 0.875rem;
            margin: 0.25rem 0;
        }
        .site-footer a {
            color: #818cf8;
            text-decoration: none;
        }
        .site-footer a:hover {
            text-decoration: underline;
        }
        .footer-privacy {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: #22c55e;
            font-weight: 500;
        }
        .footer-privacy svg {
            width: 16px;
            height: 16px;
        }
        .footer-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #334155;
        }
        .footer-nav .social-link {
            background: transparent;
            color: #64748b;
        }
        .footer-nav .social-link:hover {
            background: transparent;
            color: #94a3b8;
        }
        .footer-nav .about-btn {
            background: transparent;
            color: #64748b;
        }
        .footer-nav .about-btn:hover {
            background: transparent;
            color: #94a3b8;
        }
        .footer-divider {
            width: 1px;
            height: 24px;
            background: #475569;
        }
        .footer-meta {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            color: #64748b;
            font-size: 0.8rem;
            flex-wrap: wrap;
        }
        .footer-dot {
            color: #475569;
        }
        
        /* About Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-container {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 1rem;
            max-width: 1024px;
            max-height: 90vh;
            width: 95%;
            overflow: hidden;
            transform: translateY(20px);
            transition: transform 0.2s ease;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            will-change: transform;
        }
        .modal-overlay.active .modal-container {
            transform: translateY(0);
        }

        .modal-body {
            padding: 2rem;
            max-height: calc(90vh - 2px);
            overflow-y: auto;
        }
        
        /* Modal Content Sections */
        .modal-hero {
            text-align: center;
            margin-bottom: 2.5rem;
        }
        .modal-hero h2 {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 0.75rem;
        }
        .modal-hero p {
            color: #94a3b8;
            font-size: 1.125rem;
        }
        
        .feature-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }
        @media (max-width: 768px) {
            .feature-cards {
                grid-template-columns: 1fr;
            }
            .modal-section h3 {
                padding-left: 0;
                text-align: center;
            }
        }
        
        .modal-section h3 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #e2e8f0;
            font-size: 1.5rem;
            font-weight: 700;
            padding-left: 1.5rem;
        }
        .feature-card {
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 0.75rem;
            padding: 1.25rem;
            text-align: center;
            transition: all 0.2s ease;
            position: relative;
            top: 0;
        }
        .feature-card:hover {
            border-color: #6366f1;
        }
        .feature-card.feature-card-merge:hover {
            border-color: #6366f1;
            top: -2px;
        }
        .feature-card.feature-card-edit:hover {
            border-color: #8b5cf6;
            top: -2px;
        }
        .feature-card.feature-card-sequence:hover {
            border-color: #10b981;
            top: -2px;
        }
        .feature-card-icon {
            font-size: 2rem;
            margin-bottom: 0.75rem;
        }
        .feature-card h3 {
            color: #f8fafc;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        .feature-card p {
            color: #94a3b8;
            font-size: 0.875rem;
            line-height: 1.5;
        }
        
        .modal-section {
            margin-bottom: 2rem;
        }
        .modal-section h3 {
            color: #f8fafc;
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .modal-section ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .modal-section li {
            color: #cbd5e1;
            font-size: 0.9rem;
            padding: 0.5rem 0;
            padding-left: 1.5rem;
            position: relative;
        }
        .modal-section li::before {
            content: 'âœ“';
            position: absolute;
            left: 0;
            color: #22c55e;
            font-weight: bold;
        }
        
        /* Demo Files Section */
        .demo-section {
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 0.75rem;
            padding: 1.5rem;
        }
        .demo-section h3 {
            color: #f8fafc;
            margin-bottom: 1rem;
        }
        .demo-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }
        @media (max-width: 768px) {
            .demo-grid {
                grid-template-columns: 1fr;
            }
        }
        .demo-card {
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 0.5rem;
            padding: 1rem;
            transition: all 0.2s ease;
            position: relative;
            top: 0;
        }
        .demo-card.demo-card-merge:hover {
            border-color: #6366f1;
            top: -2px;
        }
        .demo-card.demo-card-edit:hover {
            border-color: #8b5cf6;
            top: -2px;
        }
        .demo-card.demo-card-sequence:hover {
            border-color: #10b981;
            top: -2px;
        }
        .demo-card h4 {
            color: #f8fafc;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        .demo-card p {
            color: #94a3b8;
            font-size: 0.8rem;
            margin-bottom: 0.75rem;
        }
        .demo-card-actions {
            display: flex;
            gap: 0.5rem;
        }
        .demo-btn {
            flex: 1;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .demo-btn-load {
            background: #4f46e5;
            color: white;
        }
        .demo-btn-load:hover {
            background: #6366f1;
        }
        .demo-btn-download {
            background: #334155;
            color: #94a3b8;
        }
        .demo-btn-download:hover {
            background: #475569;
            color: #f8fafc;
        }

        /* Tab Header Action Buttons */
        .tab-header-actions {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            width: 100%;
        }
        .tab-header-actions h2 {
            text-align: center;
            margin: 0;
            grid-column: 2;
        }
        .tab-header-actions .demo-load-btn-merge,
        .tab-header-actions .demo-load-btn-edit,
        .tab-header-actions .demo-load-btn-sequence {
            grid-column: 1;
            justify-self: start;
        }
        .tab-header-actions .help-btn {
            grid-column: 3;
            justify-self: end;
        }
        @media (max-width: 540px) {
            .tab-header-actions {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto;
                gap: 0.5rem;
            }
            .tab-header-actions h2 {
                grid-column: 1 / -1;
                grid-row: 2;
                font-size: 1.125rem;
            }
            .tab-header-actions .demo-load-btn-merge,
            .tab-header-actions .demo-load-btn-edit,
            .tab-header-actions .demo-load-btn-sequence {
                grid-column: 1;
                grid-row: 1;
                justify-self: start;
            }
            .tab-header-actions .help-btn {
                grid-column: 2;
                grid-row: 1;
                justify-self: end;
            }
        }
        .tab-header-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .demo-load-btn-merge {
            background: #4338ca;
            color: white;
        }
        .demo-load-btn-merge:hover {
            background: #6366f1;
        }
        .demo-load-btn-edit {
            background: #7c3aed;
            color: white;
        }
        .demo-load-btn-edit:hover {
            background: #8b5cf6;
        }
        .demo-load-btn-sequence {
            background: #059669;
            color: white;
        }
        .demo-load-btn-sequence:hover {
            background: #10b981;
        }
        .help-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 700;
            border-radius: 50%;
            border: none;
        }
        .help-btn-merge {
            background: #4338ca;
            color: white;
        }
        .help-btn-merge:hover {
            background: #6366f1;
        }
        .help-btn-edit {
            background: #7c3aed;
            color: white;
        }
        .help-btn-edit:hover {
            background: #8b5cf6;
        }
        .help-btn-sequence {
            background: #059669;
            color: white;
        }
        .help-btn-sequence:hover {
            background: #10b981;
        }

        /* Tab Button Hover Effects */
        .tab-btn {
            border: 2px solid transparent;
            transition: all 0.2s ease;
            position: relative;
            top: 0;
        }
        .tab-btn-merge:not(.tab-active):hover {
            border-color: #6366f1;
            top: -2px;
        }
        .tab-btn-edit:not(.tab-active):hover {
            border-color: #8b5cf6;
            top: -2px;
        }
        .tab-btn-sequence:not(.tab-active):hover {
            border-color: #10b981;
            top: -2px;
        }
        
        /* Custom Scrollbar Styling - Cross-browser compatible */
        /* Webkit browsers (Chrome, Safari, Opera, Edge) */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b;
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 5px;
            border: 2px solid #1e293b;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        ::-webkit-scrollbar-corner {
            background: #1e293b;
        }
        ::-webkit-scrollbar-button {
            display: none;
            height: 0;
            width: 0;
        }
        /* Firefox scrollbar */
        * {
            scrollbar-width: thin;
            scrollbar-color: #475569 #1e293b;
        }
        
        /* Number Input Spinner Styling - Cross-browser compatible */
        /* Webkit browsers (Chrome, Safari, Opera, Edge) */
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
            position: relative;
        }
        /* Custom spinner wrapper */
        .number-input-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        .number-input-wrapper input[type="number"] {
            padding-right: 24px;
        }
        .number-spinner {
            position: absolute;
            right: 4px;
            display: flex;
            flex-direction: column;
            gap: 1px;
        }
        .number-spinner button {
            width: 16px;
            height: 12px;
            padding: 0;
            border: none;
            background: #334155;
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            transition: all 0.15s ease;
            line-height: 1;
        }
        .number-spinner button:first-child {
            border-radius: 3px 3px 0 0;
        }
        .number-spinner button:last-child {
            border-radius: 0 0 3px 3px;
        }
        .number-spinner button:hover {
            background: #475569;
            color: #e2e8f0;
        }
        .number-spinner button:active {
            background: #6366f1;
            color: white;
        }
        
        /* Alternative: Show styled native spinners on hover for number inputs */
        .styled-number-input {
            position: relative;
        }
        .styled-number-input::after {
            content: '';
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: calc(100% - 8px);
            background: linear-gradient(to bottom, 
                #334155 0%, #334155 48%, 
                #1e293b 48%, #1e293b 52%, 
                #334155 52%, #334155 100%);
            border-radius: 3px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        .styled-number-input:hover::after {
            opacity: 1;
        }
        
        /* Mobile Responsive - Edit Mode */
        @media (max-width: 767px) {
            .edit-btn {
                width: 28px;
                height: 28px;
                font-size: 12px;
            }
            .edit-btn-cc {
                font-size: 9px;
                padding: 0 6px;
            }
            .dialogue-entry.selected .edit-actions-top {
                max-height: 40px;
                padding-top: 0.25rem;
            }
            .dialogue-entry.selected .edit-actions-bottom {
                max-height: 50px;
                padding-top: 0.75rem;
            }
            .dialogue-entry.selected .edit-actions-top {
                padding-bottom: 0.25rem;
            }
            .edit-timing-input {
                width: 100% !important;
                padding: 8px 10px;
                font-size: 0.85rem;
            }
            .timing-format-label {
                display: none; /* Hide format labels on mobile to save space */
            }
            .edit-text-input {
                min-height: 80px;
                padding: 8px 10px;
                font-size: 0.85rem;
            }
            /* Stack speaker name and timing vertically on mobile */
            .dialogue-entry .entry-content > div:first-child {
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }
            .dialogue-entry .speaker-name-container {
                order: 1;
                width: 100%;
                display: flex;
                justify-content: center;
            }
            .dialogue-entry.selected .speaker-name-container {
                margin-top: 1rem;
                margin-bottom: 0.75rem;
            }
            .dialogue-entry .timing-container {
                order: 2;
                flex-direction: row;
                align-items: center;
                width: 100%;
                gap: 8px;
            }
            .timing-input-group {
                flex: 1;
                width: auto;
                max-width: 160px;
            }
            .timing-separator {
                display: none; /* Hide separator dash on mobile */
            }
            .speaker-name-btn {
                font-size: 0.75rem;
                padding: 3px 0;
            }
            .dialogue-entry.selected .speaker-name-btn {
                padding: 3px 8px;
            }
            /* Mobile: Position delete button in top-right, save button in bottom-right */
            .dialogue-entry.selected {
                position: relative;
            }
            .dialogue-entry.selected .edit-actions-top {
                position: relative;
            }
            .dialogue-entry.selected .btn-delete {
                position: absolute;
                top: 8px;
                right: 8px;
                z-index: 10;
            }
            .dialogue-entry.selected .edit-actions-bottom .edit-actions-right {
                justify-content: flex-end;
            }
            .dialogue-entry.selected .btn-save {
                margin-left: auto;
            }
            /* Export buttons on mobile */
            #copyBtn, #downloadTxtBtn, #downloadSrtBtn, #downloadCsvBtn, #downloadJsonBtn {
                justify-content: center;
                width: 100%;
            }
            #copyBtn svg, #downloadTxtBtn svg, #downloadSrtBtn svg, #downloadCsvBtn svg, #downloadJsonBtn svg {
                width: 18px;
                height: 18px;
            }
            /* Export input - center text on mobile */
            #exportFileName {
                text-align: center;
            }
            /* Stats grid - display as row on mobile with compact spacing */
            #previewSection .grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.5rem;
                padding: 0.5rem;
            }
            #previewSection .grid > div {
                padding: 0;
            }
            #previewSection .grid p.text-sm {
                font-size: 0.65rem;
                margin-bottom: 0;
            }
            #previewSection .grid p.text-2xl {
                font-size: 1.25rem;
            }
            /* Footer navigation - wrap on mobile */
            .footer-nav {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
            .footer-divider {
                display: none;
            }
            /* Footer privacy - stack on mobile */
            .footer-privacy {
                flex-direction: column;
                text-align: center;
                gap: 0.25rem;
            }
            .footer-privacy svg {
                margin: 0 auto;
            }
            /* Center remove button in file rows on mobile */
            .remove-btn {
                display: flex;
                justify-content: center;
                width: 100%;
            }
            /* Center subtitle limits labels on mobile */
            #subtitleLimitsSection label,
            #subtitleLimitsSection .text-xs {
                text-align: center;
                display: block;
            }
            /* Center subtitle limits input values on mobile */
            #subtitleLimitsSection input {
                text-align: center;
            }
            /* Stack output options checkboxes on mobile */
            #outputOptionsSection .flex.flex-wrap {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
            /* Hide vertical dividers between options on mobile */
            #outputOptionsSection .w-px {
                display: none;
            }
            /* Center export label on mobile */
            #previewSection label {
                text-align: center;
                display: block;
                width: 100%;
            }
            /* Center file upload labels on mobile */
            .file-zone-container label,
            .framerate-container label,
            .speaker-label-container label,
            .duration-container label,
            #filesContainerMerge label,
            #filesContainerEdit label,
            #filesContainerSequence label,
            .part-label-container label {
                text-align: center;
            }
            /* Center sequence row controls on mobile */
            #filesContainerSequence > div > div:first-child {
                justify-content: center;
                width: 100%;
                position: relative;
            }
            /* Position sequence mobile remove button at top right */
            #filesContainerSequence .remove-btn-mobile {
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
            }
            /* Center framerate select on mobile */
            .framerate-select {
                text-align: center;
                text-align-last: center;
            }
            /* Center part-label and speaker-label inputs on mobile */
            .part-label,
            .speaker-label {
                text-align: center;
            }
        }
    </style>
</head>
<body class="bg-slate-900 p-4 md:p-6 min-h-screen text-slate-200">
    <div class="max-w-5xl mx-auto">

        <!-- App Header -->
        <div class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-white mb-2">Transcript Merger</h1>
            <p class="text-slate-400 mb-6">Merge, Edit, or Sequence DaVinci Resolve transcripts</p>
            
            <!-- Tabs -->
            <div class="flex flex-col md:flex-row justify-center gap-2 md:gap-2">
                <button id="tabMerge" class="tab-btn tab-btn-merge tab-active w-full md:w-auto px-6 py-2 rounded-full font-semibold bg-indigo-600 text-white shadow-md transition">
                    Merge Speakers
                </button>
                <button id="tabEdit" class="tab-btn tab-btn-edit w-full md:w-auto px-6 py-2 rounded-full font-semibold bg-slate-800 text-slate-400 shadow-sm transition">
                    Edit Transcripts
                </button>
                <button id="tabSequence" class="tab-btn tab-btn-sequence w-full md:w-auto px-6 py-2 rounded-full font-semibold bg-slate-800 text-slate-400 shadow-sm transition">
                    Sequence Transcripts
                </button>
            </div>
            
            <!-- Instructions (positioned below tabs) -->
            <div id="instructionsEdit" class="bg-slate-800/50 border border-slate-700 rounded-lg px-4 py-5 text-left mt-6 hidden">
                <ol class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm text-slate-300">
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-violet-500 flex-shrink-0 leading-none">1</span>
                        <span class="leading-tight">Upload a single transcript file (with or without speaker detection).</span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-violet-500 flex-shrink-0 leading-none">2</span>
                        <span class="leading-tight">Detected speakers are automatically preserved.</span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-violet-500 flex-shrink-0 leading-none">3</span>
                        <span class="leading-tight">Edit entries, then export as TXT or SRT.</span>
                    </li>
                </ol>
            </div>

            <div id="instructionsMerge" class="bg-slate-800/50 border border-slate-700 rounded-lg px-4 py-5 text-left mt-6">
                <ol class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm text-slate-300">
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-indigo-500 flex-shrink-0 leading-none">1</span>
                        <span class="leading-tight">In Resolve put each speaker on a separate audio track (Create Stems)</span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-indigo-500 flex-shrink-0 leading-none">2</span>
                        <span class="leading-tight">Transcribe each stem individually: <strong>with speaker detection DISABLED!</strong></span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-indigo-500 flex-shrink-0 leading-none">3</span>
                        <span class="leading-tight">Export each stem transcript, then upload and merge.</span>
                    </li>
                </ol>
            </div>

            <div id="instructionsSequence" class="bg-slate-800/50 border border-slate-700 rounded-lg px-4 py-5 text-left mt-6 hidden">
                <ol class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm text-slate-300">
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-emerald-500 flex-shrink-0 leading-none">1</span>
                        <span class="leading-tight">Upload transcript parts in order. Use arrows to reorder if needed.</span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-emerald-500 flex-shrink-0 leading-none">2</span>
                        <span class="leading-tight">Enter video clip duration (HH:MM:SS format).</span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-emerald-500 flex-shrink-0 leading-none">3</span>
                        <span class="leading-tight">Timestamps auto-adjust when sequenced.</span>
                    </li>
                </ol>
            </div>

        </div>

        <!-- Main Card -->
        <div class="bg-slate-800 rounded-lg shadow-lg p-4 md:p-6 mb-6 border border-slate-700">
            
            <!-- EDIT VIEW -->
            <div id="viewEdit" class="hidden">
                <div class="mb-6">
                    <div class="tab-header-actions">
                        <button class="tab-header-btn demo-load-btn-edit" onclick="loadEditDemo()">Load Demo</button>
                        <h2 class="text-2xl font-bold text-slate-100">Edit Existing Transcripts or Create</h2>
                        <button class="tab-header-btn help-btn help-btn-edit" onclick="openAboutModal()" title="About / Help">?</button>
                    </div>
                </div>
                <div id="filesContainerEdit" class="space-y-3 mb-6"></div>
            </div>

            <!-- MERGE VIEW -->
            <div id="viewMerge">
                <div class="mb-6">
                    <div class="tab-header-actions">
                        <button class="tab-header-btn demo-load-btn-merge" onclick="loadMergeDemo()">Load Demo</button>
                        <h2 class="text-2xl font-bold text-slate-100">Upload Speaker Transcriptions</h2>
                        <button class="tab-header-btn help-btn help-btn-merge" onclick="openAboutModal()" title="About / Help">?</button>
                    </div>
                </div>
                <div id="filesContainerMerge" class="space-y-3 mb-6"></div>
                <button id="addTrackBtn" class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-slate-700 text-indigo-400 rounded-lg hover:bg-slate-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 mb-6">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                    Add Another Transcription
                </button>
            </div>

            <!-- SEQUENCE VIEW -->
            <div id="viewSequence" class="hidden">
                <div class="mb-6">
                    <div class="tab-header-actions">
                        <button class="tab-header-btn demo-load-btn-sequence" onclick="loadSequenceDemo()">Load Demo</button>
                        <h2 class="text-2xl font-bold text-slate-100">Upload Transcripts and Sequence Them</h2>
                        <button class="tab-header-btn help-btn help-btn-sequence" onclick="openAboutModal()" title="About / Help">?</button>
                    </div>
                </div>
                <div id="filesContainerSequence" class="space-y-3 mb-6"></div>
                <button id="addPartBtn" class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-slate-700 text-emerald-400 rounded-lg hover:bg-slate-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-emerald-500 mb-6">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                    Add Another Transcript
                </button>
            </div>

            <!-- SUBTITLE LIMITS SETTINGS -->
            <div id="subtitleLimitsSection" class="mb-4 bg-slate-900/50 p-4 rounded-lg border border-slate-700">
                <div class="flex flex-col items-center gap-3 mb-4">
                    <h3 class="text-sm font-semibold text-slate-400 uppercase tracking-wider text-center">Subtitle Limits</h3>
                    
                    <!-- Limits Toggle -->
                    <label class="flex items-center gap-2 cursor-pointer bg-slate-800 px-3 py-1 rounded-lg border border-slate-600 hover:bg-slate-700 transition">
                        <input type="checkbox" id="toggleLimits" checked class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 bg-slate-900 border-slate-500">
                        <span class="text-xs text-slate-300 font-medium">Enable Limits</span>
                    </label>
                </div>
                
                <!-- Collapsible Settings Grid -->
                <div id="limitsSettings" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-slate-300 mb-1" title="Max characters per line (approximate)">Max Characters Per Line</label>
                        <input type="number" id="settingCpl" value="42" min="1" class="w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-slate-500" />
                        <p class="text-xs text-slate-500 mt-1">Lines may exceed to fit long words.</p>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-300 mb-1" title="Max lines per subtitle card">Max Lines Per Subtitle</label>
                        <input type="number" id="settingMaxLines" value="2" min="1" class="w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-slate-500" />
                        <p class="text-xs text-slate-500 mt-1">Card splits if text exceeds.</p>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-300 mb-1" title="Minimum display time per subtitle (seconds)">Minimum Duration (s)</label>
                        <input type="number" id="settingMinDuration" value="1.5" min="0" step="0.5" class="w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-slate-500" />
                        <p class="text-xs text-slate-500 mt-1">0 = off. Extends short subtitles.</p>
                    </div>
                </div>
            </div>

            <!-- OUTPUT OPTIONS - Separate card to show independence from Subtitle Limits -->
            <div id="outputOptionsSection" class="mb-6 bg-slate-900/50 p-4 rounded-lg border border-slate-700">
                <div class="flex flex-col items-center gap-3">
                    <h3 class="text-sm font-semibold text-slate-400 uppercase tracking-wider text-center">Output Options</h3>
                    <div class="flex flex-wrap items-center justify-center gap-3 md:gap-4">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="toggleTranscription" checked class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 bg-slate-800 border-slate-600">
                            <span class="text-sm text-slate-300">Show Transcription</span>
                        </label>
                        <div class="w-px h-4 bg-slate-700"></div>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="toggleSpeakerNames" checked class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 bg-slate-800 border-slate-600">
                            <span class="text-sm text-slate-300">Show Speakers</span>
                        </label>
                        <div class="w-px h-4 bg-slate-700"></div>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="toggleCC" checked class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 bg-slate-800 border-slate-600">
                            <span class="text-sm text-slate-300">Show CC</span>
                        </label>
                        <div class="w-px h-4 bg-slate-700"></div>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="toggleStripSilence" checked class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 bg-slate-800 border-slate-600">
                            <span class="text-sm text-slate-300">Strip Silence</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-col md:flex-row gap-3">
                <button id="processBtn" class="flex-1 bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-500 transition disabled:bg-slate-600 disabled:text-slate-400 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-slate-800">
                    Merge Transcripts
                </button>
                <button id="createTranscriptBtn" class="hidden px-4 py-3 bg-violet-600 text-white rounded-lg font-semibold hover:bg-violet-500 transition focus:outline-none focus:ring-2 focus:ring-violet-500 focus:ring-offset-2 focus:ring-offset-slate-800" onclick="createNewTranscript()">
                    Create Transcript
                </button>
                <button id="clearBtn" class="px-4 py-3 bg-red-900/30 text-red-400 rounded-lg font-semibold border border-red-900/50 shadow-sm transition-all duration-200 ease-in-out hover:bg-red-700 hover:text-white hover:border-red-600 hover:shadow-red-900/50 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-slate-800">
                    Clear All
                </button>
            </div>
        </div>

        <!-- Preview Section -->
        <div id="previewSection" class="bg-slate-800 rounded-lg shadow-lg p-4 md:p-8 hidden border border-slate-700">
            <h2 class="text-2xl font-bold text-slate-100 text-center mb-6">
                Preview
            </h2>
            <!-- Hidden entry count for JS reference -->
            <span id="entryCount" class="hidden">0</span>

            <!-- Export Row -->
            <div class="flex flex-col md:flex-row items-stretch md:items-center gap-3 mb-6 p-3 bg-slate-900 rounded-lg border border-slate-700">
                <label class="text-sm font-medium text-slate-400 whitespace-nowrap">Rename Export:</label>
                <input type="text" id="exportFileName" value="merged_transcript" class="flex-1 px-3 py-2 bg-slate-800 border border-slate-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-slate-500 text-sm" placeholder="merged_transcript" />
                <button id="copyBtn" class="flex items-center gap-2 px-4 py-2 bg-slate-700 text-slate-300 rounded-lg hover:bg-slate-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-slate-500">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"></path></svg>
                    Copy
                </button>
                <button id="downloadTxtBtn" class="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition font-medium focus:outline-none focus:ring-2 focus:ring-green-500">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                    TXT
                </button>
                <button id="downloadSrtBtn" class="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition font-medium focus:outline-none focus:ring-2 focus:ring-purple-500">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 4v16M17 4v16M3 8h4m10 0h4M3 12h18M3 16h4m10 0h4M4 20h16a1 1 0 001-1V5a1 1 0 00-1-1H4a1 1 0 00-1 1v14a1 1 0 001 1z"></path></svg>
                    SRT
                </button>
                <button id="downloadCsvBtn" class="flex items-center gap-2 px-4 py-2 bg-amber-700 text-white rounded-lg hover:bg-amber-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-amber-500">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                    CSV
                </button>
                <button id="downloadJsonBtn" class="flex items-center gap-2 px-4 py-2 bg-cyan-600 text-white rounded-lg hover:bg-cyan-700 transition font-medium focus:outline-none focus:ring-2 focus:ring-cyan-500">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path></svg>
                    JSON
                </button>
            </div>

            <!-- Stats -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6 p-4 bg-slate-900 rounded-lg border border-slate-700">
                <div class="text-center">
                    <p class="text-sm text-slate-400">Total Entries</p>
                    <p class="text-2xl font-bold text-slate-100" id="statEntries">0</p>
                </div>
                <div class="text-center">
                    <p class="text-sm text-slate-400">Duration</p>
                    <p class="text-2xl font-bold text-slate-100" id="statDuration">0m</p>
                </div>
                <div class="text-center">
                    <p class="text-sm text-slate-400">Speakers</p>
                    <p class="text-2xl font-bold text-slate-100" id="statSpeakers">0</p>
                </div>
            </div>

            <!-- Preview List (Increased Height) -->
            <div id="previewList" class="max-h-[800px] overflow-y-auto space-y-4 border border-slate-700 rounded-lg p-4 bg-slate-900"></div>
        </div>

        <!-- Site Footer -->
        <footer class="site-footer">
            <!-- Social Links & About Button -->
            <div class="footer-nav">
                <a href="https://forcequitproductions.com/" class="social-link" title="Website" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="2" y1="12" x2="22" y2="12"></line>
                        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1 4-10z"></path>
                    </svg>
                </a>
                <a href="https://www.youtube.com/@ForceQuitCreations" class="social-link" title="YouTube" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                    </svg>
                </a>
                <a href="https://www.instagram.com/forcequit_music/" class="social-link" title="Instagram" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
                    </svg>
                </a>
                <a href="https://x.com/ForceQuit_YT" class="social-link" title="Twitter/X" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                    </svg>
                </a>
                <a href="https://github.com/forcequit-me" class="social-link" title="GitHub" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                    </svg>
                </a>
                <a href="https://linktr.ee/ForceQuit" class="social-link" title="Linktree" target="_blank" rel="noopener">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M7.953 15.066l-.038-4.044-4.044-.02v2.084l2.115-.02.02 2.138zM15.83 9.092l-.02 2.114-2.114-.02v-2.085l-1.907 1.945 1.927 2.01v6.907h2.066V13.09l1.946-1.897-1.898-2.102zM20.129 15.066l.02-2.138 2.115.02V10.864l-4.044.02-.039 4.044-2.009-1.965-1.965 1.946 3.955 4.025v-3.868h1.967zM7.953 8.954l2.009 2.05-2.02 1.955-1.945-1.916v-2.09H3.871V7.001l4.074-.039v2.032l-2.038-.02v.02zM12.05 2l-2.01 2.058v4.035l2.01 2.01 2.029-2.01v-4.15l-2.029-1.943z"/>
                    </svg>
                </a>
                <div class="footer-divider"></div>
                <button id="aboutBtn" class="about-btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="16" x2="12" y2="12"></line>
                        <line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                    About
                </button>
                <div class="footer-divider"></div>
                <a class="gumroad-button support-btn" href="https://forcequit.gumroad.com/l/vkahtw" data-gumroad-overlay-checkout="true" target="_blank" rel="noopener">Support me on</a>
            </div>
            
            <!-- Privacy Badge -->
            <p class="footer-privacy">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                </svg>
                100% Private â€” All processing happens locally in your browser
            </p>
            
            <!-- Attribution -->
            <div class="footer-meta">
                <span>Works in Chrome, Firefox, Edge, Safari, and Opera</span>
                <span class="footer-dot">â€¢</span>
                <span>Made with â™¥ for the DaVinci Resolve community</span>
            </div>
        </footer>
    </div>

    <!-- About Modal -->
    <div id="aboutModal" class="modal-overlay">
        <div class="modal-container">

            <div class="modal-body">
                <!-- Hero -->
                <div class="modal-hero">
                    <h2><span style="color: #6366f1;">Merge.</span> <span style="color: #8b5cf6;">Edit.</span> <span style="color: #10b981;">Sequence.</span></h2>
                    <p>The missing tool for DaVinci Resolve transcripts.</p>
                </div>

                <!-- Feature Cards -->
                <div class="feature-cards">
                    <div class="feature-card feature-card-merge">
                        <div class="feature-card-icon">ðŸŽ™ï¸</div>
                        <h3>Merge Speakers</h3>
                        <p>Combine separate speaker tracks into one chronological dialogue.</p>
                    </div>
                    <div class="feature-card feature-card-edit">
                        <div class="feature-card-icon">âœï¸</div>
                        <h3>Edit Transcripts</h3>
                        <p>Fix speaker labels, correct text, adjust timing. Works standalone or after merge/sequence.</p>
                    </div>
                    <div class="feature-card feature-card-sequence">
                        <div class="feature-card-icon">ðŸŽ¬</div>
                        <h3>Sequence Parts</h3>
                        <p>Combine transcripts from multiple timeline segments by specifying each part's duration.</p>
                    </div>
                </div>

                <!-- Why Use This -->
                <div class="modal-section">
                    <h3>Why This Tool Exists</h3>
                    <p style="color: #cbd5e1; margin-bottom: 0.5rem; padding-left: 1.5rem; font-weight: 500;">DaVinci Resolve has the best transcription quality compared to Adobe Premiere and Descriptâ€”but all three have unreliable speaker detection. This tool solves that problem.</p>
                    <ul>
                        <li><strong>Bypass bad speaker detection:</strong> Record each speaker to separate audio tracks, transcribe them individually, then merge here with correct speaker labels.</li>
                        <li><strong>Fix mistakes anywhere:</strong> Edit speaker names, correct transcription errors, or adjust timingâ€”all inline, in any mode.</li>
                        <li><strong>Rejoin split timelines:</strong> Transcribed clips separately? Sequence mode recalculates timecodes so everything lines up correctly.</li>
                    </ul>
                </div>

                <!-- Feature Highlights -->
                <div class="modal-section">
                    <h3>Feature Highlights</h3>
                    <ul>
                        <li><strong>Per-file framerate control</strong> â€” Supports HH:MM:SS:FF timecode (23.976 to 120 fps, or custom up to 999.999).</li>
                        <li><strong>Framerate mismatch warning</strong> â€” Prevents processing if files have different framerates.</li>
                        <li><strong>Per-tab settings</strong> â€” Switching tabs preserves your subtitle limits and output options.</li>
                        <li><strong>Inline editing</strong> â€” Modify speaker, text, timing; add/remove entries without leaving the page.</li>
                        <li><strong>Rename speakers globally</strong> â€” One change applies to all occurrences.</li>
                        <li><strong>Subtitle limits</strong> â€” Set max characters per line, max lines, and minimum duration.</li>
                        <li><strong>Multiple exports</strong> â€” Download as SRT, TXT, CSV, JSON, or copy to clipboard.</li>
                        <li><strong>Keyboard shortcuts</strong> â€” Enter to confirm, Ctrl+Enter to save edits, Escape to cancel, Arrow keys for timing.</li>
                        <li><strong>Export CC Only</strong> â€” Uncheck "Show Transcription" to export only closed captions.</li>
                    </ul>
                </div>
                <!-- Feedback & Updates -->
                <div class="modal-section" style="text-align: center;">

                    <h3 style="justify-content: center; padding-left: 0; margin-bottom: 0.5rem;">Feedback & Updates</h3>
                    <p style="color: #94a3b8; margin-top: 0; margin-bottom: 1rem;">Have feedback or a feature request? Let me know on GitHub or Social Media!</p>
                    <div style="display: flex; gap: 0.75rem; justify-content: center;">
                        <!-- Social Links (Copied from Header) -->
                        <a href="https://forcequitproductions.com/" class="social-link" title="Website" target="_blank" rel="noopener">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"></circle>
                                <line x1="2" y1="12" x2="22" y2="12"></line>
                                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                            </svg>
                        </a>
                        <a href="https://www.youtube.com/@ForceQuitCreations" class="social-link" title="YouTube" target="_blank" rel="noopener">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
                            </svg>
                        </a>
                        <a href="https://www.instagram.com/forcequit_music/" class="social-link" title="Instagram" target="_blank" rel="noopener">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
                            </svg>
                        </a>
                        <a href="https://x.com/ForceQuit_YT" class="social-link" title="Twitter/X" target="_blank" rel="noopener">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                            </svg>
                        </a>
                        <a href="https://github.com/forcequit-me" class="social-link" title="GitHub" target="_blank" rel="noopener">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                            </svg>
                        </a>
                        <a href="https://linktr.ee/ForceQuit" class="social-link" title="Linktree" target="_blank" rel="noopener">
                            <svg viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7.953 15.066l-.038-4.044-4.044-.02v2.084l2.115-.02.02 2.138zM15.83 9.092l-.02 2.114-2.114-.02v-2.085l-1.907 1.945 1.927 2.01v6.907h2.066V13.09l1.946-1.897-1.898-2.102zM20.129 15.066l.02-2.138 2.115.02V10.864l-4.044.02-.039 4.044-2.009-1.965-1.965 1.946 3.955 4.025v-3.868h1.967zM7.953 8.954l2.009 2.05-2.02 1.955-1.945-1.916v-2.09H3.871V7.001l4.074-.039v2.032l-2.038-.02v.02zM12.05 2l-2.01 2.058v4.035l2.01 2.01 2.029-2.01v-4.15l-2.029-1.943z"/>
                            </svg>
                        </a>
                    </div>
                    <a class="gumroad-button support-btn-modal" href="https://forcequit.gumroad.com/l/vkahtw" data-gumroad-overlay-checkout="true" target="_blank" rel="noopener" style="margin-top: 1.25rem;">Support me on</a>
                </div>

                <!-- Demo Files Section -->
                <div class="demo-section">
                    <h3>Try It With Demo Files</h3>
                    <p style="color: #94a3b8; margin-bottom: 1rem;">Want to test the tool before using your own transcripts? Load these sample files:</p>
                    <div class="demo-grid">
                        <div class="demo-card demo-card-merge">
                            <h4>Merge Demo</h4>
                            <p>Two speaker transcript files to combine into a conversation.</p>
                            <div class="demo-card-actions" style="flex-direction: column; gap: 0.5rem;">
                                <button class="demo-btn demo-btn-load" onclick="loadMergeDemo()" style="background: #6366f1;">Load Demo</button>
                                <div style="display: flex; gap: 0.25rem;">
                                    <button class="demo-btn demo-btn-download" onclick="downloadFile(DEMO_FILES.merge_speaker_a, 'demo_speaker_a.txt')" style="font-size: 0.7rem; display: inline-flex; align-items: center; justify-content: center; gap: 4px;"><svg style="width:11px;height:11px;flex-shrink:0;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>Speaker A</button>
                                    <button class="demo-btn demo-btn-download" onclick="downloadFile(DEMO_FILES.merge_speaker_b, 'demo_speaker_b.txt')" style="font-size: 0.7rem; display: inline-flex; align-items: center; justify-content: center; gap: 4px;"><svg style="width:11px;height:11px;flex-shrink:0;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>Speaker B</button>
                                </div>
                            </div>
                        </div>
                        <div class="demo-card demo-card-edit">
                            <h4>Edit Demo</h4>
                            <p>A single transcript with mixed speakers and CC entries.</p>
                            <div class="demo-card-actions" style="flex-direction: column; gap: 0.5rem;">
                                <button class="demo-btn demo-btn-load" onclick="loadEditDemo()" style="background: #8b5cf6;">Load Demo</button>
                                <button class="demo-btn demo-btn-download" onclick="downloadFile(DEMO_FILES.edit_transcript, 'demo_edit.txt')" style="font-size: 0.7rem; display: inline-flex; align-items: center; justify-content: center; gap: 4px;"><svg style="width:11px;height:11px;flex-shrink:0;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>Download</button>
                            </div>
                        </div>
                        <div class="demo-card demo-card-sequence">
                            <h4>Sequence Demo</h4>
                            <p>Two transcript parts from a split timeline to sequence together.</p>
                            <div class="demo-card-actions" style="flex-direction: column; gap: 0.5rem;">
                                <button class="demo-btn demo-btn-load" onclick="loadSequenceDemo()" style="background: #10b981;">Load Demo</button>
                                <div style="display: flex; gap: 0.25rem;">
                                    <button class="demo-btn demo-btn-download" onclick="downloadFile(DEMO_FILES.sequence_part1, 'demo_part1.txt')" style="font-size: 0.7rem; display: inline-flex; align-items: center; justify-content: center; gap: 4px;"><svg style="width:11px;height:11px;flex-shrink:0;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>Part 1</button>
                                    <button class="demo-btn demo-btn-download" onclick="downloadFile(DEMO_FILES.sequence_part2, 'demo_part2.txt')" style="font-size: 0.7rem; display: inline-flex; align-items: center; justify-content: center; gap: 4px;"><svg style="width:11px;height:11px;flex-shrink:0;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>Part 2</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // STATE
        let currentMode = 'merge'; // 'edit', 'merge', or 'sequence'
        let editFile = null; // Single file for edit mode
        let mergeFiles = [];
        let sequenceFiles = [];
        let fileIdCounter = 0;
        let processedData = null;
        let rawProcessedData = null; // Stores pre-limit data to preserve edits when limits change
        let previewMode = null; // Track which mode generated the current preview
        
        // PER-TAB SETTINGS AND DATA: Each tab has its own settings and preview data
        const tabSettings = {
            edit: { cpl: 42, maxLines: 2, minDuration: 1.5, enableLimits: true, showSpeakers: true, showCC: true, showTranscription: true, stripSilence: true, processedData: null, rawProcessedData: null },
            merge: { cpl: 42, maxLines: 2, minDuration: 1.5, enableLimits: true, showSpeakers: true, showCC: true, showTranscription: true, stripSilence: true, processedData: null, rawProcessedData: null },
            sequence: { cpl: 42, maxLines: 2, minDuration: 1.5, enableLimits: true, showSpeakers: true, showCC: true, showTranscription: true, stripSilence: true, processedData: null, rawProcessedData: null }
        };


        // DEMO FILE DATA (embedded for single-file portability)
        // Format matches DaVinci Resolve transcript export: [START - END] \n Speaker \n text
        const DEMO_FILES = {
            merge_speaker_a: `[00:00:00:00 - 00:00:02:00]
Speaker 1
 (Intro music)

[00:00:02:00 - 00:00:08:00]
Speaker 1
Hey, welcome to the show! Thanks for joining us today.

[00:00:08:15 - 00:00:16:00]
Speaker 1
So I wanted to talk about something really interesting that happened last week.

[00:00:16:00 - 00:00:18:00]
Speaker 1
 (Silence)

[00:00:18:00 - 00:00:28:00]
Speaker 1
Yeah, the response from the community was just incredible.

[00:00:28:12 - 00:00:42:00]
Speaker 1
I think what made it special was how everyone came together.

[00:00:42:00 - 00:00:52:00]
Speaker 1
Anyway, let's move on to our main topic for today.

[00:00:52:18 - 00:01:05:00]
Speaker 1
We're going to be discussing video editing workflows.

[00:01:05:00 - 00:01:12:00]
Speaker 1
And specifically, how transcripts can save you hours of time.
`,
            merge_speaker_b: `[00:00:05:12 - 00:00:14:00]
Speaker 1
Thanks for having me! I'm excited to be here.

[00:00:14:00 - 00:00:20:00]
Speaker 1
Oh really? What happened?

[00:00:20:00 - 00:00:23:08]
Speaker 1
 (Silence)

[00:00:23:08 - 00:00:35:00]
Speaker 1
That's awesome! I saw some of the posts online.

[00:00:35:20 - 00:00:40:00]
Speaker 1
Absolutely. It really shows what's possible when people collaborate.

[00:00:40:00 - 00:00:48:00]
Speaker 1
 (Laughter)

[00:00:48:06 - 00:00:58:00]
Speaker 1
Sounds good, I'm ready!

[00:00:58:00 - 00:01:05:00]
Speaker 1
Perfect, that's such an important topic.

[00:01:12:15 - 00:01:20:00]
Speaker 1
Definitely. I've started using transcripts for all my projects now.
`,
            sequence_part1: `[01:00:00:00 - 01:00:03:00]
Speaker 1
 (Upbeat intro music)

[01:00:03:00 - 01:00:08:00]
Speaker 1
Welcome back to part one of our tutorial series.

[01:00:08:15 - 01:00:18:00]
Speaker 1
Today we're going to cover the basics of color grading.

[01:00:18:00 - 01:00:20:00]
Speaker 1
 (Mouse clicking)

[01:00:20:00 - 01:00:32:00]
Speaker 1
First, let's open up the color page in DaVinci Resolve.

[01:00:32:12 - 01:00:45:00]
Speaker 1
You'll notice the node graph on the right side of the screen.

[01:00:45:00 - 01:01:02:00]
Speaker 1
This is where all the magic happens.

[01:01:02:00 - 01:01:02:18]
Speaker 1
 (Silence)

[01:01:02:18 - 01:01:15:00]
Speaker 1
Let's add our first correction node.

[01:01:15:00 - 01:01:28:00]
Speaker 1
I'll start by adjusting the lift, gamma, and gain.

[01:01:28:06 - 01:01:42:00]
Speaker 1
See how that immediately changes the mood of the shot?

[01:01:42:00 - 01:02:00:00]
Speaker 1
Now let's move on to the next technique.

[01:02:00:00 - 01:02:05:00]
Speaker 1
We'll pick this up in part two.
`,
            sequence_part2: `[01:00:00:00 - 01:00:10:00]
Speaker 1
Welcome back to part two of our color grading tutorial.

[01:00:10:00 - 01:00:22:00]
Speaker 1
In this section, we'll cover secondary corrections.

[01:00:22:15 - 01:00:38:00]
Speaker 1
Secondary corrections let you isolate specific parts of the image.

[01:00:38:00 - 01:00:52:00]
Speaker 1
For example, you can target just the sky or just skin tones.

[01:00:52:12 - 01:01:08:00]
Speaker 1
Let me show you how to use the qualifier tool.

[01:01:08:00 - 01:01:25:00]
Speaker 1
I'll select the eyedropper and click on the area I want to isolate.

[01:01:25:18 - 01:01:42:00]
Speaker 1
Now I can adjust just this selected region.

[01:01:42:00 - 01:01:52:00]
Speaker 1
This is incredibly powerful for fixing problem areas.

[01:01:52:00 - 01:01:54:00]
Speaker 1
 (Silence)

[01:01:54:00 - 01:01:58:00]
Speaker 1
 (Keyboard typing)

[01:01:58:00 - 01:02:05:00]
Speaker 1
And that wraps up our tutorial series!

[01:02:05:00 - 01:02:10:00]
Speaker 1
 (Outro music)
`,
            edit_transcript: `[00:00:03:00 - 00:00:10:00]
Speaker 1
Hello everyone, and welcome to today's discussion.

[00:00:10:15 - 00:00:18:00]
Speaker 2
Thanks for the introduction! Great to be here.

[00:00:18:00 - 00:00:25:00]
Speaker 1
So let's dive right into the topic at hand.

[00:00:25:12 - 00:00:33:00]
Speaker 2
Absolutely. I've been looking forward to this.

[00:00:33:00 - 00:00:42:00]
Speaker 1
First question: what got you started in this field?

[00:00:42:18 - 00:00:55:00]
Speaker 2
Well, it all began about ten years ago when I was in college.

[00:00:55:00 - 00:01:02:00]
Speaker 1
That's fascinating. Tell us more about that experience.

[00:01:02:00 - 00:01:05:00]
Speaker 1
 (Silence)

[00:01:05:12 - 00:01:18:00]
Speaker 2
I took a class that completely changed my perspective.

[00:01:18:00 - 00:01:22:00]
Speaker 1
 (Background music)

[00:01:22:00 - 00:01:32:00]
Speaker 1
And how did that lead to where you are today?

[00:01:32:15 - 00:01:45:00]
Speaker 2
It was a long journey, but here we are!

[00:01:45:00 - 00:01:50:00]
Speaker 1
 (Applause)
`
        };

        // ABOUT MODAL FUNCTIONS
        function openAboutModal() {
            document.getElementById('aboutModal').classList.add('active');
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }
        
        function closeAboutModal() {
            document.getElementById('aboutModal').classList.remove('active');
            document.body.style.overflow = ''; // Restore scrolling
        }

        // DEMO FILE FUNCTIONS
        function createDemoFile(content, filename) {
            return new File([content], filename, { type: 'text/plain' });
        }

        function loadMergeDemo() {
            closeAboutModal();
            switchTab('merge');
            
            // Clear existing files
            mergeFiles = [];
            filesContainerMerge.innerHTML = '';
            
            // Use addMergeFile to create proper DOM structure, then populate
            addMergeFile(); // Creates first file slot
            addMergeFile(); // Creates second file slot
            
            // Get the file objects we just created
            const fileA = mergeFiles[0];
            const fileB = mergeFiles[1];
            
            // Populate first file (Alice)
            fileA.file = createDemoFile(DEMO_FILES.merge_speaker_a, 'demo_speaker_alice.txt');
            fileA.label = 'Alice';
            fileA.framerate = '24';
            const elemA = document.getElementById(`file-merge-${fileA.id}`);
            if (elemA) {
                elemA.querySelector('.speaker-label').value = 'Alice';
                elemA.querySelector('.file-zone-container .file-name').textContent = 'demo_speaker_alice.txt';
                elemA.querySelector('.framerate-select').value = '24';
            }
            
            // Populate second file (Bob)
            fileB.file = createDemoFile(DEMO_FILES.merge_speaker_b, 'demo_speaker_bob.txt');
            fileB.label = 'Bob';
            fileB.framerate = '24';
            const elemB = document.getElementById(`file-merge-${fileB.id}`);
            if (elemB) {
                elemB.querySelector('.speaker-label').value = 'Bob';
                elemB.querySelector('.file-zone-container .file-name').textContent = 'demo_speaker_bob.txt';
                elemB.querySelector('.framerate-select').value = '24';
            }
            
            updateProcessButtonState();
        }

        function loadSequenceDemo() {
            closeAboutModal();
            switchTab('sequence');
            
            // Clear existing files
            sequenceFiles = [];
            filesContainerSequence.innerHTML = '';
            
            // Use addSequenceFile to create proper DOM structure
            addSequenceFile(); // Creates first file slot
            addSequenceFile(); // Creates second file slot
            
            // Get the file objects we just created
            const file1 = sequenceFiles[0];
            const file2 = sequenceFiles[1];
            
            // Populate first file (Part 1)
            file1.file = createDemoFile(DEMO_FILES.sequence_part1, 'demo_part1.txt');
            file1.label = 'Part 1';
            file1.duration = '0000:02:00';
            file1.framerate = '24';
            const elem1 = document.getElementById(`file-seq-${file1.id}`);
            if (elem1) {
                elem1.querySelector('.part-label').value = 'Part 1';
                elem1.querySelector('.file-zone-container .file-name').textContent = 'demo_part1.txt';
                elem1.querySelector('.duration-input').value = '0000:02:00';
                elem1.querySelector('.framerate-select').value = '24';
            }
            
            // Populate second file (Part 2)
            file2.file = createDemoFile(DEMO_FILES.sequence_part2, 'demo_part2.txt');
            file2.label = 'Part 2';
            file2.duration = '0000:02:05';
            file2.framerate = '24';
            const elem2 = document.getElementById(`file-seq-${file2.id}`);
            if (elem2) {
                elem2.querySelector('.part-label').value = 'Part 2';
                elem2.querySelector('.file-zone-container .file-name').textContent = 'demo_part2.txt';
                elem2.querySelector('.duration-input').value = '0000:02:05';
                elem2.querySelector('.framerate-select').value = '24';
            }
            
            updateSequenceIndices();
            updateProcessButtonState();
        }

        function loadEditDemo() {
            closeAboutModal();
            switchTab('edit');
            
            // Set the edit file directly (matching normal file upload behavior at line 1692)
            editFile = createDemoFile(DEMO_FILES.edit_transcript, 'demo_transcript.txt');
            
            // Update the file display
            const fileZone = filesContainerEdit.querySelector('.file-zone-container .file-name');
            if (fileZone) {
                fileZone.textContent = 'demo_transcript.txt';
            }
            
            // Update framerate select
            const framerateSelect = filesContainerEdit.querySelector('.framerate-select');
            if (framerateSelect) {
                framerateSelect.value = '24';
            }
            
            updateProcessButtonState();
        }

        function createNewTranscript() {
            const starterTranscript = `[00:00:00:00 - 00:00:05:00]
Speaker 1
Your story begins...
`;
            // Set the edit file
            editFile = createDemoFile(starterTranscript, 'new_transcript.txt');

            // Update the file display
            const fileZone = filesContainerEdit.querySelector('.file-zone-container .file-name');
            if (fileZone) {
                fileZone.textContent = 'new_transcript.txt';
            }

            // Update framerate select to default
            const framerateSelect = filesContainerEdit.querySelector('.framerate-select');
            if (framerateSelect) {
                framerateSelect.value = '24';
            }

            updateProcessButtonState();

            // Automatically process to open the editor
            processTranscripts();
        }

        function downloadFile(content, filename) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // DOM ELEMENTS
        const tabEdit = document.getElementById('tabEdit');
        const tabMerge = document.getElementById('tabMerge');
        const tabSequence = document.getElementById('tabSequence');
        const viewEdit = document.getElementById('viewEdit');
        const viewMerge = document.getElementById('viewMerge');
        const viewSequence = document.getElementById('viewSequence');
        const instructionsEdit = document.getElementById('instructionsEdit');
        const instructionsMerge = document.getElementById('instructionsMerge');
        const instructionsSequence = document.getElementById('instructionsSequence');
        
        const filesContainerEdit = document.getElementById('filesContainerEdit');
        const filesContainerMerge = document.getElementById('filesContainerMerge');
        const filesContainerSequence = document.getElementById('filesContainerSequence');
        
        const processBtn = document.getElementById('processBtn');
        
        // TABS LOGIC
        // Base classes preserved, mode-specific classes added for hover effects
        const inactiveTabBaseClass = "tab-btn w-full md:w-auto px-6 py-2 rounded-full font-semibold bg-slate-800 text-slate-400 shadow-sm transition";
        
        function switchTab(mode) {
            // SAVE CURRENT TAB SETTINGS AND DATA before switching
            if (currentMode) {
                tabSettings[currentMode] = {
                    cpl: parseInt(document.getElementById('settingCpl').value) || 42,
                    maxLines: parseInt(document.getElementById('settingMaxLines').value) || 2,
                    minDuration: parseFloat(document.getElementById('settingMinDuration').value) || 1.5,
                    enableLimits: document.getElementById('toggleLimits').checked,
                    showSpeakers: document.getElementById('toggleSpeakerNames').checked,
                    showCC: document.getElementById('toggleCC').checked,
                    stripSilence: document.getElementById('toggleStripSilence').checked,
                    // Save preview data for this tab
                    processedData: processedData,
                    rawProcessedData: rawProcessedData
                };
            }
            
            currentMode = mode;
            const subtitleLimitsSection = document.getElementById('subtitleLimitsSection');
            
            // RESTORE NEW TAB SETTINGS AND DATA
            const settings = tabSettings[mode];
            document.getElementById('settingCpl').value = settings.cpl;
            document.getElementById('settingMaxLines').value = settings.maxLines;
            document.getElementById('settingMinDuration').value = settings.minDuration;
            document.getElementById('toggleLimits').checked = settings.enableLimits;
            document.getElementById('toggleSpeakerNames').checked = settings.showSpeakers;
            document.getElementById('toggleCC').checked = settings.showCC;
            document.getElementById('toggleStripSilence').checked = settings.stripSilence;
            // Restore preview data for this tab
            processedData = settings.processedData;
            rawProcessedData = settings.rawProcessedData;
            previewMode = processedData ? mode : null;
            
            // Reset all tabs to inactive with their mode-specific hover classes
            tabEdit.className = inactiveTabBaseClass + " tab-btn-edit";
            tabMerge.className = inactiveTabBaseClass + " tab-btn-merge";
            tabSequence.className = inactiveTabBaseClass + " tab-btn-sequence";
            
            // Hide all views and instructions
            viewEdit.classList.add('hidden');
            viewMerge.classList.add('hidden');
            viewSequence.classList.add('hidden');
            instructionsEdit.classList.add('hidden');
            instructionsMerge.classList.add('hidden');
            instructionsSequence.classList.add('hidden');
            
            // Get export filename input for updating defaults
            const exportFileNameInput = document.getElementById('exportFileName');
            
            // Get Create Transcript button
            const createTranscriptBtn = document.getElementById('createTranscriptBtn');

            if (mode === 'edit') {
                tabEdit.className = "tab-btn tab-btn-edit tab-active w-full md:w-auto px-6 py-2 rounded-full font-semibold bg-violet-600 text-white shadow-md transition";
                viewEdit.classList.remove('hidden');
                instructionsEdit.classList.remove('hidden');
                subtitleLimitsSection.classList.remove('hidden');
                processBtn.textContent = "Edit Transcript";
                processBtn.className = processBtn.className
                    .replace(/bg-(indigo|emerald)-600/g, 'bg-violet-600')
                    .replace(/hover:bg-(indigo|emerald)-500/g, 'hover:bg-violet-500');
                // Show Create Transcript button in edit mode
                if (createTranscriptBtn) createTranscriptBtn.classList.remove('hidden');
                // Set default export filename for edit mode
                if (exportFileNameInput && (exportFileNameInput.value === 'merged_transcript' || exportFileNameInput.value === 'sequenced_transcript')) {
                    exportFileNameInput.value = 'edited_transcript';
                    exportFileNameInput.placeholder = 'edited_transcript';
                }
            } else if (mode === 'merge') {
                tabMerge.className = "tab-btn tab-btn-merge tab-active w-full md:w-auto px-6 py-2 rounded-full font-semibold bg-indigo-600 text-white shadow-md transition";
                viewMerge.classList.remove('hidden');
                instructionsMerge.classList.remove('hidden');
                subtitleLimitsSection.classList.remove('hidden');
                processBtn.textContent = "Merge Transcripts";
                processBtn.className = processBtn.className
                    .replace(/bg-(violet|emerald)-600/g, 'bg-indigo-600')
                    .replace(/hover:bg-(violet|emerald)-500/g, 'hover:bg-indigo-500');
                // Hide Create Transcript button in merge mode
                if (createTranscriptBtn) createTranscriptBtn.classList.add('hidden');
                // Set default export filename for merge mode
                if (exportFileNameInput && (exportFileNameInput.value === 'edited_transcript' || exportFileNameInput.value === 'sequenced_transcript')) {
                    exportFileNameInput.value = 'merged_transcript';
                    exportFileNameInput.placeholder = 'merged_transcript';
                }
            } else {
                tabSequence.className = "tab-btn tab-btn-sequence tab-active w-full md:w-auto px-6 py-2 rounded-full font-semibold bg-emerald-600 text-white shadow-md transition";
                viewSequence.classList.remove('hidden');
                instructionsSequence.classList.remove('hidden');
                subtitleLimitsSection.classList.remove('hidden');
                processBtn.textContent = "Sequence Transcripts";
                processBtn.className = processBtn.className
                    .replace(/bg-(violet|indigo)-600/g, 'bg-emerald-600')
                    .replace(/hover:bg-(violet|indigo)-500/g, 'hover:bg-emerald-500');
                // Hide Create Transcript button in sequence mode
                if (createTranscriptBtn) createTranscriptBtn.classList.add('hidden');
                // Set default export filename for sequence mode
                if (exportFileNameInput && (exportFileNameInput.value === 'merged_transcript' || exportFileNameInput.value === 'edited_transcript')) {
                    exportFileNameInput.value = 'sequenced_transcript';
                    exportFileNameInput.placeholder = 'sequenced_transcript';
                }
            }
            
            // Show/hide and refresh preview based on per-tab data
            if (processedData !== null) {
                document.getElementById('previewSection').classList.remove('hidden');
                displayPreview(true); // Re-render the preview with this tab's data
            } else {
                document.getElementById('previewSection').classList.add('hidden');
                document.getElementById('previewList').innerHTML = '';
            }
            
            updateProcessButtonState();
        }

        tabEdit.addEventListener('click', () => switchTab('edit'));
        tabMerge.addEventListener('click', () => switchTab('merge'));
        tabSequence.addEventListener('click', () => switchTab('sequence'));

        // FILE HANDLING
        function createUploadZone(fileObj, onFileSelect) {
            const zone = document.createElement('label');
            zone.className = "flex items-center justify-center w-full px-4 py-2 border-2 border-dashed border-slate-600 rounded-lg cursor-pointer hover:border-indigo-500 transition focus-within:ring-2 focus-within:ring-indigo-500 focus-within:border-indigo-500 bg-slate-900/50";
            zone.innerHTML = `
                <div class="flex items-center gap-2">
                    <svg class="w-4 h-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                    </svg>
                    <span class="text-sm text-slate-400 file-name">${fileObj.file ? fileObj.file.name : 'Click or Drag file'}</span>
                </div>
                <input type="file" accept=".txt" class="sr-only file-input" />
            `;

            const input = zone.querySelector('input');
            
            // Drag & Drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.add('drag-active'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.remove('drag-active'), false);
            });

            zone.addEventListener('drop', (e) => {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files[0]) handleFile(files[0]);
            });

            input.addEventListener('change', (e) => {
                if (e.target.files[0]) handleFile(e.target.files[0]);
            });

            function handleFile(file) {
                fileObj.file = file;
                zone.querySelector('.file-name').textContent = file.name;
                onFileSelect();
            }

            return zone;
        }

        function initEditFile() {
            // Create single file upload for edit mode
            const fileItem = document.createElement('div');
            fileItem.className = 'bg-slate-900/50 p-3 rounded-lg border border-slate-700';
            fileItem.id = 'file-edit';
            
            fileItem.innerHTML = `
                <div class="flex flex-col md:flex-row gap-3 items-stretch md:items-start">
                    <div class="flex-1 file-zone-container">
                        <label class="block text-sm font-medium text-slate-300 mb-1">Transcript File</label>
                    </div>
                    <div class="w-full md:w-28 framerate-container">
                        <label class="block text-sm font-medium text-slate-300 mb-1">Framerate</label>
                        <select class="framerate-select w-full px-2 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-amber-500 text-white text-sm">
                            <option value="ignore" selected>Ignore</option>
                            <option value="23.976">23.976</option>
                            <option value="24">24</option>
                            <option value="25">25</option>
                            <option value="29.97">29.97</option>
                            <option value="30">30</option>
                            <option value="50">50</option>
                            <option value="59.94">59.94</option>
                            <option value="60">60</option>
                            <option value="120">120</option>
                            <option value="custom">+ Custom...</option>
                        </select>
                        <input type="number" class="framerate-custom hidden w-full mt-1 px-2 py-1 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-amber-500 text-white text-sm text-center" placeholder="fps" min="1" max="999.999" step="0.001" />
                    </div>
                </div>
            `;

            const fileObj = { file: null };
            const zone = document.createElement('label');
            zone.className = "flex items-center justify-center w-full px-4 py-3 border-2 border-dashed border-slate-600 rounded-lg cursor-pointer hover:border-amber-500 transition focus-within:ring-2 focus-within:ring-amber-500 focus-within:border-amber-500 bg-slate-900/50";
            zone.innerHTML = `
                <div class="flex items-center gap-2">
                    <svg class="w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                    </svg>
                    <span class="text-sm text-slate-400 file-name">Click or Drag transcript file</span>
                </div>
                <input type="file" accept=".txt" class="sr-only file-input" />
            `;

            const input = zone.querySelector('input');
            
            // Drag & Drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.add('drag-active'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.remove('drag-active'), false);
            });

            zone.addEventListener('drop', (e) => {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files[0]) handleFile(files[0]);
            });

            input.addEventListener('change', (e) => {
                if (e.target.files[0]) handleFile(e.target.files[0]);
            });

            function handleFile(file) {
                editFile = file;
                zone.querySelector('.file-name').textContent = file.name;
                updateProcessButtonState();
            }

            fileItem.querySelector('.file-zone-container').appendChild(zone);
            
            // Framerate select with custom option support
            const framerateSelect = fileItem.querySelector('.framerate-select');
            const framerateCustom = fileItem.querySelector('.framerate-custom');
            framerateSelect.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    framerateCustom.classList.remove('hidden');
                    framerateCustom.focus();
                } else {
                    framerateCustom.classList.add('hidden');
                }
            });
            framerateCustom.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value);
                if (val > 999.999) {
                    e.target.value = "999.999";
                }
            });
            framerateCustom.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur();
                }
            });
            
            filesContainerEdit.appendChild(fileItem);
        }

        function addMergeFile() {
            const id = fileIdCounter++;
            const fileItem = document.createElement('div');
            fileItem.className = 'flex flex-col md:flex-row gap-3 items-stretch md:items-start bg-slate-900/50 p-3 rounded-lg border border-slate-700';
            fileItem.id = `file-merge-${id}`;
            
            const fileObj = { id, element: fileItem, file: null, label: `Speaker ${mergeFiles.length + 1}`, framerate: 'ignore' };
            mergeFiles.push(fileObj);

            fileItem.innerHTML = `
                <div class="flex-1">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Speaker Label</label>
                    <input type="text" value="${fileObj.label}" class="speaker-label w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-slate-500" placeholder="e.g., John" />
                </div>
                <div class="flex-1 file-zone-container">
                    <label class="block text-sm font-medium text-slate-300 mb-1">File</label>
                </div>
                <div class="w-full md:w-28 framerate-container">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Framerate</label>
                    <select class="framerate-select w-full px-2 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white text-sm">
                        <option value="ignore" selected>Ignore</option>
                        <option value="23.976">23.976</option>
                        <option value="24">24</option>
                        <option value="25">25</option>
                        <option value="29.97">29.97</option>
                        <option value="30">30</option>
                        <option value="50">50</option>
                        <option value="59.94">59.94</option>
                        <option value="60">60</option>
                        <option value="120">120</option>
                        <option value="custom">+ Custom...</option>
                    </select>
                    <input type="number" class="framerate-custom hidden w-full mt-1 px-2 py-1 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white text-sm text-center" placeholder="fps" min="1" max="999.999" step="0.001" />
                </div>
                <div class="flex flex-col">
                    <span class="hidden md:block text-sm font-medium text-transparent mb-1 select-none" aria-hidden="true">&nbsp;</span>
                    <button class="remove-btn px-3 py-2 text-red-400 bg-transparent rounded-lg transition-colors duration-200 hover:bg-red-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-red-500">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                </div>
            `;

            const zone = createUploadZone(fileObj, () => {
                if (fileObj.file) {
                    const name = fileObj.file.name.replace(/\.[^/.]+$/, "");
                    fileObj.label = name;
                    fileItem.querySelector('.speaker-label').value = name;
                }
                updateProcessButtonState();
            });
            fileItem.querySelector('.file-zone-container').appendChild(zone);

            const speakerLabelInput = fileItem.querySelector('.speaker-label');
            speakerLabelInput.addEventListener('input', (e) => fileObj.label = e.target.value);
            speakerLabelInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur();
                }
            });
            
            // Framerate select with custom option support
            const framerateSelect = fileItem.querySelector('.framerate-select');
            const framerateCustom = fileItem.querySelector('.framerate-custom');
            framerateSelect.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    framerateCustom.classList.remove('hidden');
                    framerateCustom.focus();
                } else {
                    framerateCustom.classList.add('hidden');
                    fileObj.framerate = e.target.value;
                    updateProcessButtonState();
                }
            });
            framerateCustom.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value);
                if (val > 999.999) {
                    val = 999.999;
                    e.target.value = "999.999";
                }
                if (val > 0) {
                    fileObj.framerate = String(val);
                    updateProcessButtonState();
                }
            });
            framerateCustom.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur();
                }
            });
            fileItem.querySelector('.remove-btn').addEventListener('click', () => {
                mergeFiles = mergeFiles.filter(f => f.id !== id);
                fileItem.remove();
                updateProcessButtonState();
            });

            filesContainerMerge.appendChild(fileItem);
            updateProcessButtonState();
        }

        function addSequenceFile() {
            const id = fileIdCounter++;
            const fileItem = document.createElement('div');
            fileItem.className = 'flex flex-col md:flex-row gap-3 items-stretch md:items-start bg-slate-900/50 p-3 rounded-lg border border-slate-700 relative';
            fileItem.id = `file-seq-${id}`;
            
            const fileObj = { id, element: fileItem, file: null, duration: "0000:00:00", label: `Part ${sequenceFiles.length + 1}`, framerate: 'ignore' };
            sequenceFiles.push(fileObj);

            fileItem.innerHTML = `
                <div class="flex md:hidden items-center justify-between w-full pb-2 border-b border-slate-700 mb-1">
                    <div class="flex items-center gap-2">
                        <button class="move-up-mobile text-slate-500 hover:text-slate-300 p-1"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></button>
                        <span class="text-xs font-bold text-slate-500 index-badge-mobile">#${sequenceFiles.length}</span>
                        <button class="move-down-mobile text-slate-500 hover:text-slate-300 p-1"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>
                    </div>
                    <button class="remove-btn-mobile px-2 py-1 text-red-400 bg-transparent rounded-lg transition-colors duration-200 hover:bg-red-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-red-500">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                </div>
                <div class="hidden md:flex flex-col items-center justify-center self-stretch" style="margin-top: 24px;">
                    <button class="move-up text-slate-500 hover:text-slate-300"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></button>
                    <span class="text-xs font-bold text-slate-500 index-badge">#${sequenceFiles.length}</span>
                    <button class="move-down text-slate-500 hover:text-slate-300"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>
                </div>
                <div class="flex-1">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Part Label</label>
                    <input type="text" value="${fileObj.label}" class="part-label w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 text-white placeholder-slate-500" placeholder="e.g., Part 1" />
                </div>
                <div class="flex-1 file-zone-container">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Transcript File</label>
                </div>
                <div class="w-full md:w-36">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Duration</label>
                    <input type="text" value="0000:00:00" class="duration-input w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 text-center font-mono text-white" placeholder="HHHH:MM:SS" />
                </div>
                <div class="w-full md:w-28 framerate-container">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Framerate</label>
                    <select class="framerate-select w-full px-2 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 text-white text-sm">
                        <option value="ignore" selected>Ignore</option>
                        <option value="23.976">23.976</option>
                        <option value="24">24</option>
                        <option value="25">25</option>
                        <option value="29.97">29.97</option>
                        <option value="30">30</option>
                        <option value="50">50</option>
                        <option value="59.94">59.94</option>
                        <option value="60">60</option>
                        <option value="120">120</option>
                        <option value="custom">+ Custom...</option>
                    </select>
                    <input type="number" class="framerate-custom hidden w-full mt-1 px-2 py-1 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 text-white text-sm text-center" placeholder="fps" min="1" max="999.999" step="0.001" />
                </div>
                <div class="hidden md:flex flex-row md:flex-col justify-between md:justify-start items-center md:items-stretch gap-2">
            <span class="hidden md:block text-sm font-medium text-transparent mb-1 select-none" aria-hidden="true">&nbsp;</span>
            <button class="remove-btn px-3 py-2 text-red-400 bg-transparent rounded-lg transition-colors duration-200 hover:bg-red-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-red-500">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                </div>
            `;

            const zone = createUploadZone(fileObj, () => {
                // Auto-populate label from filename when file is uploaded
                if (fileObj.file) {
                    const name = fileObj.file.name;
                    fileObj.label = name;
                    fileItem.querySelector('.part-label').value = name;
                }
                updateProcessButtonState();
            });
            fileItem.querySelector('.file-zone-container').appendChild(zone);

            // Part label input handler
            const partLabelInput = fileItem.querySelector('.part-label');
            partLabelInput.addEventListener('input', (e) => fileObj.label = e.target.value);
            partLabelInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur();
                }
            });
            
            // Framerate select with custom option support
            const framerateSelect = fileItem.querySelector('.framerate-select');
            const framerateCustom = fileItem.querySelector('.framerate-custom');
            framerateSelect.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    framerateCustom.classList.remove('hidden');
                    framerateCustom.focus();
                } else {
                    framerateCustom.classList.add('hidden');
                    fileObj.framerate = e.target.value;
                    updateProcessButtonState();
                }
            });
            framerateCustom.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value);
                if (val > 999.999) {
                    val = 999.999;
                    e.target.value = "999.999";
                }
                if (val > 0) {
                    fileObj.framerate = String(val);
                    updateProcessButtonState();
                }
            });
            framerateCustom.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur();
                }
            });

            const durationInput = fileItem.querySelector('.duration-input');
            
            // STATE: Track which field is being edited and digit position within field
            let activeFieldIndex = 0;  // 0=hours, 1=minutes, 2=seconds
            let digitPosition = 0;     // Current digit position within the field (0-3 for hours, 0-1 for min/sec)
            let pendingDigits = '';    // Accumulated digits for current field
            
            // Helper to select a specific field
            function selectField(input, fieldIndex) {
                const ranges = [
                    [0, 4],   // Hours (4 digits)
                    [5, 7],   // Minutes
                    [8, 10]   // Seconds
                ];
                const [start, end] = ranges[fieldIndex];
                input.setSelectionRange(start, end);
                activeFieldIndex = fieldIndex;
                digitPosition = 0;  // Reset digit position when field is selected
                pendingDigits = ''; // Clear pending digits
            }
            
            // Get field index from cursor position (for clicks)
            function getFieldFromPosition(pos) {
                if (pos <= 4) return 0; // Hours (0-4)
                if (pos <= 7) return 1; // Minutes (5-7)
                return 2; // Seconds (8-10)
            }
            
            // Parse current value into array [hours, minutes, seconds]
            function parseValue(value) {
                const parts = value.split(':');
                return [
                    (parts[0] || '0000').padStart(4, '0'),
                    (parts[1] || '00').padStart(2, '0'),
                    (parts[2] || '00').padStart(2, '0')
                ];
            }
            
            // Format array back to HHHH:MM:SS
            function formatValue(parts) {
                return `${parts[0].padStart(4, '0')}:${parts[1].padStart(2, '0')}:${parts[2].padStart(2, '0')}`;
            }
            
            // Get the number of digits for a field
            function getFieldDigits(fieldIndex) {
                return fieldIndex === 0 ? 4 : 2; // Hours = 4 digits, Min/Sec = 2 digits
            }
            
            // Get zero value for a field
            function getZeroValue(fieldIndex) {
                return fieldIndex === 0 ? '0000' : '00';
            }
            
            durationInput.addEventListener('keydown', (e) => {
                // Allow tab to move to next input
                if (e.key === 'Tab') {
                    digitPosition = 0;
                    pendingDigits = '';
                    return;
                }
                
                // Allow Ctrl/Cmd shortcuts
                if (e.ctrlKey || e.metaKey) {
                    return;
                }
                
                // Arrow left - move to previous field
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (activeFieldIndex > 0) {
                        selectField(e.target, activeFieldIndex - 1);
                    }
                    return;
                }
                
                // Arrow right - move to next field
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (activeFieldIndex < 2) {
                        selectField(e.target, activeFieldIndex + 1);
                    }
                    return;
                }
                
                // Home - select hours
                if (e.key === 'Home') {
                    e.preventDefault();
                    selectField(e.target, 0);
                    return;
                }
                
                // End - select seconds
                if (e.key === 'End') {
                    e.preventDefault();
                    selectField(e.target, 2);
                    return;
                }
                
                const parts = parseValue(e.target.value);
                
                // Backspace - delete one digit at a time
                if (e.key === 'Backspace' || e.key === 'Delete') {
                    e.preventDefault();
                    
                    const zeroVal = getZeroValue(activeFieldIndex);
                    
                    // If we were in the middle of entering digits, just clear and stay on this field
                    if (digitPosition > 0) {
                        parts[activeFieldIndex] = zeroVal;
                        e.target.value = formatValue(parts);
                        fileObj.duration = e.target.value;
                        digitPosition = 0;
                        pendingDigits = '';
                        selectField(e.target, activeFieldIndex);  // Stay on current field
                        return;
                    }
                    
                    // Check if already zero before attempting deletion
                    const wasAlreadyZero = parts[activeFieldIndex] === zeroVal;
                    
                    if (wasAlreadyZero && activeFieldIndex > 0) {
                        // Already at zero, move to previous field
                        selectField(e.target, activeFieldIndex - 1);
                    } else if (!wasAlreadyZero) {
                        // Shift digits right (remove rightmost, pad left with 0)
                        const currentValue = parts[activeFieldIndex];
                        const shifted = '0' + currentValue.slice(0, -1);
                        parts[activeFieldIndex] = shifted;
                        
                        e.target.value = formatValue(parts);
                        fileObj.duration = e.target.value;
                        
                        // Check if we just made it zero - move to previous field
                        if (parts[activeFieldIndex] === zeroVal && activeFieldIndex > 0) {
                            selectField(e.target, activeFieldIndex - 1);
                        } else {
                            selectField(e.target, activeFieldIndex);
                        }
                    } else {
                        // Already zero but on first field (hours), just stay
                        selectField(e.target, activeFieldIndex);
                    }
                    return;
                }
                
                // Handle digit input
                if (/[0-9]/.test(e.key)) {
                    e.preventDefault();
                    
                    const maxDigits = getFieldDigits(activeFieldIndex);
                    let fieldValue;
                    let shouldAdvance = false;
                    
                    // Add digit to pending
                    pendingDigits += e.key;
                    digitPosition++;
                    
                    if (digitPosition < maxDigits) {
                        // Still building the field value
                        fieldValue = pendingDigits.padStart(maxDigits, '0');
                    } else {
                        // Field is complete
                        fieldValue = pendingDigits.slice(-maxDigits); // Take last N digits
                        const val = parseInt(fieldValue);
                        
                        // Block invalid values for minutes/seconds (must be <= 59)
                        if (activeFieldIndex > 0 && val > 59) {
                            // Invalid input - revert to previous digits minus last
                            pendingDigits = pendingDigits.slice(0, -1);
                            digitPosition--;
                            return;
                        }
                        
                        shouldAdvance = true;
                    }
                    
                    parts[activeFieldIndex] = fieldValue;
                    e.target.value = formatValue(parts);
                    fileObj.duration = e.target.value;
                    
                    // Auto-advance to next field if appropriate
                    if (shouldAdvance && activeFieldIndex < 2) {
                        selectField(e.target, activeFieldIndex + 1);
                    } else if (shouldAdvance) {
                        // On last field after completing digits, re-select it
                        selectField(e.target, activeFieldIndex);
                    } else {
                        // Still entering digits, position cursor BEFORE the next digit slot
                        const ranges = [
                            [0, 4],   // Hours (4 digits)
                            [5, 7],   // Minutes
                            [8, 10]   // Seconds
                        ];
                        const [start, end] = ranges[activeFieldIndex];
                        // Position cursor at the next digit to be entered
                        const cursorPos = start + digitPosition;
                        e.target.setSelectionRange(cursorPos, cursorPos);
                    }
                    return;
                }
                
                // Enter key to confirm/blur
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur();
                    return;
                }
                
                // Block all other keys
                e.preventDefault();
            });
            
            // Click to select the field that was clicked
            durationInput.addEventListener('click', (e) => {
                const field = getFieldFromPosition(e.target.selectionStart);
                selectField(e.target, field);
            });
            
            // Focus to select hours by default (for tab navigation)
            durationInput.addEventListener('focus', (e) => {
                selectField(e.target, 0);
            });
            
            // Prevent pasting
            durationInput.addEventListener('paste', (e) => {
                e.preventDefault();
            });
            
            // Auto-reprocess when duration changes (if preview already exists)
            durationInput.addEventListener('change', () => {
                if (previewMode === 'sequence' && processedData !== null) {
                    processTranscripts();
                }
            });
            
            // Reordering Logic - Desktop
            fileItem.querySelector('.move-up').addEventListener('click', () => moveFile(id, -1));
            fileItem.querySelector('.move-down').addEventListener('click', () => moveFile(id, 1));
            
            // Reordering Logic - Mobile
            fileItem.querySelector('.move-up-mobile').addEventListener('click', () => moveFile(id, -1));
            fileItem.querySelector('.move-down-mobile').addEventListener('click', () => moveFile(id, 1));

            // Remove button - Desktop
            fileItem.querySelector('.remove-btn').addEventListener('click', () => {
                sequenceFiles = sequenceFiles.filter(f => f.id !== id);
                fileItem.remove();
                updateSequenceIndices();
                updateProcessButtonState();
            });
            
            // Remove button - Mobile
            fileItem.querySelector('.remove-btn-mobile').addEventListener('click', () => {
                sequenceFiles = sequenceFiles.filter(f => f.id !== id);
                fileItem.remove();
                updateSequenceIndices();
                updateProcessButtonState();
            });

            filesContainerSequence.appendChild(fileItem);
            updateSequenceIndices();
            updateProcessButtonState();
        }

        function moveFile(id, direction) {
            const index = sequenceFiles.findIndex(f => f.id === id);
            if (index < 0) return;
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= sequenceFiles.length) return;

            // Swap in array
            [sequenceFiles[index], sequenceFiles[newIndex]] = [sequenceFiles[newIndex], sequenceFiles[index]];
            
            // Swap in DOM
            const container = filesContainerSequence;
            const items = Array.from(container.children);
            if (direction === -1) {
                container.insertBefore(items[index], items[newIndex]);
            } else {
                container.insertBefore(items[newIndex], items[index]);
            }
            
            updateSequenceIndices();
            
            // Auto-reprocess when order changes (if preview already exists)
            if (previewMode === 'sequence' && processedData !== null) {
                processTranscripts();
            }
        }

        function updateSequenceIndices() {
            sequenceFiles.forEach((f, idx) => {
                f.element.querySelector('.index-badge').textContent = `#${idx + 1}`;
                const mobileIndexBadge = f.element.querySelector('.index-badge-mobile');
                if (mobileIndexBadge) {
                    mobileIndexBadge.textContent = `#${idx + 1}`;
                }
            });
        }

        function updateProcessButtonState() {
            let hasFiles = false;
            let framerateMismatch = false;
            
            // Determine if we have files
            if (currentMode === 'edit') {
                hasFiles = editFile !== null;
            } else if (currentMode === 'merge') {
                hasFiles = mergeFiles.length > 0 && mergeFiles.every(f => f.file);
                
                // Check framerate consistency
                if (hasFiles && mergeFiles.length > 1) {
                    const framerates = mergeFiles.map(f => f.framerate || 'ignore');
                    const uniqueFramerates = [...new Set(framerates)];
                    framerateMismatch = uniqueFramerates.length > 1;
                    
                    // Update UI for mismatch highlighting
                    updateFramerateMismatchUI(mergeFiles, framerateMismatch, filesContainerMerge);
                }
            } else {
                hasFiles = sequenceFiles.length > 0 && sequenceFiles.every(f => f.file);
                
                // Check framerate consistency
                if (hasFiles && sequenceFiles.length > 1) {
                    const framerates = sequenceFiles.map(f => f.framerate || 'ignore');
                    const uniqueFramerates = [...new Set(framerates)];
                    framerateMismatch = uniqueFramerates.length > 1;
                    
                    // Update UI for mismatch highlighting
                    updateFramerateMismatchUI(sequenceFiles, framerateMismatch, filesContainerSequence);
                }
            }
            
            // Update button state and text
            processBtn.disabled = !hasFiles || framerateMismatch;
            if (framerateMismatch) {
                processBtn.textContent = 'âš  Framerates Mismatch';
                processBtn.title = 'All files must have the same framerate setting';
            } else {
                processBtn.textContent = 'Process Transcripts';
                processBtn.title = '';
            }
        }
        
        function updateFramerateMismatchUI(files, hasMismatch, container) {
            // Remove existing warning
            const existingWarning = container.querySelector('.framerate-warning');
            if (existingWarning) existingWarning.remove();
            
            // Find the most common framerate to highlight mismatches
            const framerateCounts = {};
            files.forEach(f => {
                const fr = f.framerate || 'ignore';
                framerateCounts[fr] = (framerateCounts[fr] || 0) + 1;
            });
            const mostCommon = Object.entries(framerateCounts).sort((a, b) => b[1] - a[1])[0]?.[0];
            
            // Update each file's UI
            files.forEach(f => {
                const frContainer = f.element.querySelector('.framerate-container');
                if (frContainer) {
                    const fr = f.framerate || 'ignore';
                    if (hasMismatch && fr !== mostCommon) {
                        frContainer.classList.add('framerate-mismatch');
                    } else {
                        frContainer.classList.remove('framerate-mismatch');
                    }
                }
            });
            
            // Add warning banner if mismatch
            if (hasMismatch) {
                const warning = document.createElement('div');
                warning.className = 'framerate-warning';
                warning.innerHTML = `
                    <svg class="framerate-warning-icon w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                    </svg>
                    <span class="framerate-warning-text">
                        <strong>Framerate mismatch:</strong> All files must use the same framerate. Adjust the highlighted dropdowns.
                    </span>
                `;
                container.insertBefore(warning, container.firstChild);
            }
        }

        // PARSING & PROCESSING
        function parseTimecode(timecodeStr) {
            const match = timecodeStr.match(/\[(\d+):(\d+):(\d+):(\d+)\s*-/);
            if (match) {
                const [, h, m, s, ff] = match.map(Number);
                return h * 3600 + m * 60 + s + ff / 30;
            }
            return 0;
        }

        function parseDuration(durationStr) {
            const parts = durationStr.split(':').map(Number);
            if (parts.length === 3) {
                return parts[0] * 3600 + parts[1] * 60 + parts[2];
            }
            return 0;
        }

        function formatTimecode(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const ff = Math.floor((seconds % 1) * 30);
            return `${String(h).padStart(4,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}:${String(ff).padStart(2,'0')}`;
        }

        async function parseTranscript(content, speakerLabel, timeOffset = 0) {
            const entries = [];
            const blocks = content.split(/\n(?=\[)/);

            blocks.forEach(block => {
                const lines = block.trim().split('\n');
                if (!lines[0].startsWith('[')) return;

                const timecodeMatch = lines[0].match(/\[(\d+):(\d+):(\d+):(\d+)\s*-\s*(\d+):(\d+):(\d+):(\d+)\]/);
                if (!timecodeMatch) return;

                // Parse Start
                let startSec = parseInt(timecodeMatch[1])*3600 + parseInt(timecodeMatch[2])*60 + parseInt(timecodeMatch[3]) + parseInt(timecodeMatch[4])/30;
                // Parse End
                let endSec = parseInt(timecodeMatch[5])*3600 + parseInt(timecodeMatch[6])*60 + parseInt(timecodeMatch[7]) + parseInt(timecodeMatch[8])/30;

                // Apply Offset
                startSec += timeOffset;
                endSec += timeOffset;

                const newTimecode = `[${formatTimecode(startSec)} - ${formatTimecode(endSec)}]`;

                let textStart = 1;
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].startsWith('Speaker')) {
                        textStart = i + 1;
                        break;
                    }
                }

                const text = lines.slice(textStart).join('\n').trim();
                if (text) {
                    entries.push({
                        startSeconds: startSec,
                        endSeconds: endSec,
                        timecode: newTimecode,
                        speaker: speakerLabel,
                        text
                    });
                }
            });
            return entries;
        }

        async function processTranscripts() {
            try {
                let allEntries = [];

                if (currentMode === 'edit') {
                    // Edit mode: single file with auto speaker detection
                    const content = await editFile.text();
                    const entries = await parseTranscript(content, null, 0); // null = use detected speakers
                    
                    // Normalize base timecode offset (DaVinci Resolve often starts at 01:00:00:00)
                    if (entries.length > 0) {
                        const baseOffset = entries[0].startSeconds;
                        entries.forEach(entry => {
                            entry.startSeconds = entry.startSeconds - baseOffset;
                            entry.endSeconds = entry.endSeconds - baseOffset;
                            entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
                        });
                    }
                    
                    allEntries = entries;
                    allEntries.sort((a, b) => a.startSeconds - b.startSeconds);
                } else if (currentMode === 'merge') {
                    // Collect all entries first, then normalize based on the earliest timestamp
                    let rawEntries = [];
                    for (const fileObj of mergeFiles) {
                        const content = await fileObj.file.text();
                        const entries = await parseTranscript(content, fileObj.label, 0);
                        rawEntries = rawEntries.concat(entries);
                    }
                    rawEntries.sort((a, b) => a.startSeconds - b.startSeconds);
                    
                    // Normalize base timecode offset (DaVinci Resolve often starts at 01:00:00:00)
                    if (rawEntries.length > 0) {
                        const baseOffset = rawEntries[0].startSeconds;
                        rawEntries.forEach(entry => {
                            entry.startSeconds = entry.startSeconds - baseOffset;
                            entry.endSeconds = entry.endSeconds - baseOffset;
                            entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
                        });
                    }
                    
                    allEntries = rawEntries;
                } else {
                    let currentOffset = 0;
                    let partIndex = 1;
                    for (const fileObj of sequenceFiles) {
                        const content = await fileObj.file.text();
                        
                        // Parse entries WITHOUT offset first to detect base timecode
                        const rawEntries = await parseTranscript(content, null, 0);
                        
                        if (rawEntries.length > 0) {
                            // Detect the base timecode offset from the first entry
                            // DaVinci Resolve often uses record timecode starting at 01:00:00:00
                            // We need to normalize this to relative time (starting at 0)
                            const baseOffset = rawEntries[0].startSeconds;
                            
                            // Apply normalization: subtract base offset, then add cumulative sequence offset
                            rawEntries.forEach(entry => {
                                entry.startSeconds = entry.startSeconds - baseOffset + currentOffset;
                                entry.endSeconds = entry.endSeconds - baseOffset + currentOffset;
                                entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
                                entry.partNumber = partIndex;
                                entry.partLabel = fileObj.label; // Store the custom part label
                            });
                            
                            allEntries = allEntries.concat(rawEntries);
                        }
                        
                        currentOffset += parseDuration(fileObj.duration);
                        partIndex++;
                    }
                }

                // 1. FLATTEN TIME SLICES (Merge overlapping CC/Dialogue)
                // Creates a linear, non-overlapping stream with composite Text
                let flattenedEntries = flattenTracks(allEntries);
                
                // Assign unique IDs to each entry for tracking edits
                flattenedEntries.forEach((entry, idx) => {
                    entry.rawId = idx;
                });

                // 2. STORE RAW DATA (before limits) to preserve edits when limits change
                rawProcessedData = flattenedEntries;

                // 3. APPLY SUBTITLE LIMITS (All modes when enabled)
                const cpl = parseInt(document.getElementById('settingCpl').value) || 42;
                const maxLines = parseInt(document.getElementById('settingMaxLines').value) || 2;
                const enableLimits = document.getElementById('toggleLimits').checked;
                
                // Apply limits in all modes when enabled
                if (enableLimits) {
                    processedData = applyLimits(rawProcessedData.map(e => ({...e})), cpl, maxLines);
                } else {
                    processedData = rawProcessedData.map(e => ({...e}));
                }
                
                previewMode = currentMode; // Store which mode generated this preview
                displayPreview();
            } catch (error) {
                alert('Error processing files: ' + error.message);
                console.error(error);
            }
        }
        
        function flattenTracks(entries) {
            if (entries.length === 0) return [];
            
            // HELPER: Normalize text for comparison (lowercase, no punctuation)
            const normalizeText = (str) => str.toLowerCase().replace(/[^\w\s]/g, '').replace(/\s+/g, ' ').trim();
            
            // HELPER: Smart merge text - avoids duplicates and subsets
            const smartMergeText = (currentText, nextText) => {
                const currentNorm = normalizeText(currentText);
                const nextNorm = normalizeText(nextText);
                
                // If texts are identical (normalized), keep current
                if (currentNorm === nextNorm) {
                    return currentText;
                }
                
                // If next is a subset of current, keep current
                if (currentNorm.includes(nextNorm)) {
                    return currentText;
                }
                
                // If current is a subset of next, prefer next (it's more complete)
                if (nextNorm.includes(currentNorm)) {
                    return nextText;
                }
                
                // Genuinely different content - combine them
                return currentText + " " + nextText;
            };
            
            // 0. SEPARATE TRACKS
            const ccEntries = [];
            const diagEntries = [];
            
            entries.forEach(e => {
                if (e.speaker === '[CC]') {
                    ccEntries.push(e);
                } else {
                    diagEntries.push(e);
                }
            });
            
            // 1. CLEAN & MERGE CC TRACKS (Aggressive Merge for identical SFX)
            // Goal: Overlapping "(Phone Beeps)" from multiple files should become ONE entry.
            function mergeCC(cclist) {
                if (cclist.length === 0) return [];
                // Sort by Start Time for merging logic
                cclist.sort((a, b) => a.startSeconds - b.startSeconds);
                
                const merged = [];
                let current = { ...cclist[0] };
                
                for (let i = 1; i < cclist.length; i++) {
                    const next = cclist[i];
                    
                    // Overlap?
                    if (next.startSeconds < current.endSeconds + 0.1) {
                        // If same text, merge them into one long block
                        if (current.text === next.text) {
                            current.endSeconds = Math.max(current.endSeconds, next.endSeconds);
                            // Keep earliest start
                        } else {
                            // Different CC text overlapping?
                            // Just flow them naturally. 
                            // If Next starts before Current ends, we can't easily merge different texts in CC without clutter.
                            // But usually CC is sparse. Let's push current and start new.
                            merged.push(current);
                            current = { ...next };
                        }
                    } else {
                        merged.push(current);
                        current = { ...next };
                    }
                }
                merged.push(current);
                return merged;
            }
            
            const cleanCC = mergeCC(ccEntries);
            
            // 2. CLEAN & MERGE DIALOGUE TRACKS (Heal fragmented lines)
            // Goal: If "Samantha" is split into two parts by "Theodore" in the input file (old logic artifact),
            // or if the user uploads a file with split lines, we want to re-join them into one "block" 
            // so they sort correctly by End Time.
            function mergeDialogue(dlist) {
                if (dlist.length === 0) return [];
                // Sort by Start Time to find adjacent fragments
                dlist.sort((a, b) => a.startSeconds - b.startSeconds);
                
                const merged = [];
                let current = { ...dlist[0] };
                
                for (let i = 1; i < dlist.length; i++) {
                    const next = dlist[i];
                    
                    // Check strict adjacency (Gap < 0.5s) AND Same Speaker
                    // We assume inputs are "Tracks", so same speaker name = same person.
                    const gap = next.startSeconds - current.endSeconds;
                    const isSameSpeaker = current.speaker === next.speaker;
                    
                    // Allow small overlap or small gap
                    const isAdjacent = gap < 0.5; // 0.5s tolerance for "sentence pause"
                    
                    if (isSameSpeaker && (isAdjacent || next.startSeconds < current.endSeconds)) {
                        // MERGE
                        current.endSeconds = Math.max(current.endSeconds, next.endSeconds);
                        current.startSeconds = Math.min(current.startSeconds, next.startSeconds); // Should be current.start, but safety
                        
                        // Merge Text (Smart deduplication)
                        current.text = smartMergeText(current.text, next.text);
                    } else {
                         merged.push(current);
                         current = { ...next };
                    }
                }
                merged.push(current);
                return merged;
            }

            const cleanDialogue = mergeDialogue(diagEntries);
            
            // 3. COMBINE & SORT BY END TIME (User Request: "Who stops talking last")
            // This ensures short interjections (ending early) appear before the long speech (ending late) finishes.
            
            let allClean = [...cleanCC, ...cleanDialogue];
            
            // SORT LOGIC: End Time ASC, then Start Time ASC
            allClean.sort((a, b) => {
                if (Math.abs(a.endSeconds - b.endSeconds) > 0.05) {
                    return a.endSeconds - b.endSeconds;
                }
                return a.startSeconds - b.startSeconds;
            });
            
            // 4. FINAL PASS: MERGE ADJACENT SAME-SPEAKER
            // If the sorted list has two adjacent entries from SAME speaker, merge them.
            // This handles the case where we just sorted them together.
            
            const finalMerged = [];
            if (allClean.length > 0) {
                let current = allClean[0];
                
                for (let i = 1; i < allClean.length; i++) {
                    const next = allClean[i];
                    
                    const isSameSpeaker = current.speaker === next.speaker;
                    // Check adjacency (current end ~ next start) OR Overlap
                    // Since we sorted by End Time, 'next' could actually start BEFORE 'current'.
                    // Merge if:
                    // 1. Same Speaker
                    // 2. Gap is small (< 0.5s) OR Overlapping
                    const gap = next.startSeconds - current.endSeconds;
                    const isClose = gap < 0.5; // Allow small silence to bridge
                    // Also check if 'next' is completely contained or overlapping significantly?
                    // If we merge, we extend End Time.
                    
                    if (isSameSpeaker && (isClose || next.startSeconds < current.endSeconds)) {
                        // MERGE
                        // Update End
                        current.endSeconds = Math.max(current.endSeconds, next.endSeconds);
                        // Update Start (if next started earlier, which is possible with End-Sort)
                        current.startSeconds = Math.min(current.startSeconds, next.startSeconds);
                        
                        // Merge Text (Smart deduplication)
                        current.text = smartMergeText(current.text, next.text);
                        
                        // Update Timecode
                        current.timecode = `[${formatTimecode(current.startSeconds)} - ${formatTimecode(current.endSeconds)}]`;
                        
                    } else {
                        finalMerged.push(current);
                        current = next;
                    }
                }
                finalMerged.push(current);
            }
            
            return finalMerged;
        }
        
        // LIMIT LOGIC
        function applyLimits(entries, cplLimit, maxLinesLimit) {
            let newEntries = [];
            
            entries.forEach(entry => {
                // 1. PURE CC: Pass through (Exempt)
                if (entry.speaker === '[CC]') {
                    newEntries.push(entry);
                    return;
                }

                // 2. COMPOSITE CARD (CC Header + Dialogue Body)
                // Identified by empty speaker (baked into text)
                if (entry.speaker === '') {
                    const lines = entry.text.split('\n');
                    if (lines.length > 1) {
                         // Detach CC Header
                         const header = lines[0];
                         const body = lines.slice(1).join('\n');
                         
                         // Process Body (Dialogue) against limits
                         // We create a temp entry for the splitter
                         const tempEntry = { ...entry, text: body };
                         const splitEntries = createLimitEntries(tempEntry, cplLimit, maxLinesLimit);
                         
                         // Re-attach Header to the FIRST card only
                         if (splitEntries.length > 0) {
                             splitEntries[0].text = header + '\n' + splitEntries[0].text;
                         }
                         
                         newEntries = newEntries.concat(splitEntries);
                         return;
                    }
                    // Fallback if split failed or single line? Treat as normal.
                }

                // 3. STANDARD DIALOGUE
                const splitEntries = createLimitEntries(entry, cplLimit, maxLinesLimit);
                newEntries = newEntries.concat(splitEntries);
            });
            
            return newEntries;
        }
        
        function createLimitEntries(originalEntry, cpl, maxLines) {
            // 1. Wrap logic (Greedy Overflow)
            const words = originalEntry.text.split(/\s+/);
            const lines = [];
            let currentLine = [];
            let currentLen = 0;
            
            words.forEach(word => {
                const wordLen = word.length;
                // Add 1 for space if line not empty
                const spaceLen = currentLine.length > 0 ? 1 : 0;
                
                // Add word to current line tentatively
                currentLine.push(word);
                currentLen += spaceLen + wordLen;
                
                // Check if we exceeded the limit
                if (currentLen > cpl) {
                    // Line is full. Commit.
                    lines.push(currentLine.join(' '));
                    currentLine = [];
                    currentLen = 0;
                }
            });
            
            // Push remaining
            if (currentLine.length > 0) {
                lines.push(currentLine.join(' '));
            }
            
            // 2. Pagination logic
            const pages = [];
            for (let i = 0; i < lines.length; i += maxLines) {
                pages.push(lines.slice(i, i + maxLines).join('\n'));
            }
            
            if (pages.length === 1) {
                return [{
                    ...originalEntry,
                    text: pages[0]
                }];
            }
            
            // 3. Timestamp Interpolation
            const totalDuration = originalEntry.endSeconds - originalEntry.startSeconds;
            const totalChars = pages.reduce((acc, page) => acc + page.length, 0); 
            
            let currentStart = originalEntry.startSeconds;
            const resultEntries = [];
            
            pages.forEach((pageText, idx) => {
                const charCount = pageText.length;
                const fraction = totalChars > 0 ? (charCount / totalChars) : (1 / pages.length);
                let duration = totalDuration * fraction;
                
                let pageEnd = currentStart + duration;
                
                if (idx === pages.length - 1) {
                    pageEnd = originalEntry.endSeconds;
                }
                
                resultEntries.push({
                    startSeconds: currentStart,
                    endSeconds: pageEnd,
                    timecode: `[${formatTimecode(currentStart)} - ${formatTimecode(pageEnd)}]`,
                    speaker: originalEntry.speaker,
                    text: pageText,
                    partNumber: originalEntry.partNumber, // Preserve part number for sequencer mode
                    partLabel: originalEntry.partLabel, // Preserve part label for sequencer mode
                    rawId: originalEntry.rawId // Preserve link to raw data for edit syncing
                });
                
                currentStart = pageEnd;
            });
            
            return resultEntries;
        }
        
        // Re-apply limits to rawProcessedData without re-parsing files
        // This preserves all user edits (text, speaker, timing, added/deleted entries)
        function reapplyLimits() {
            if (!rawProcessedData) return;
            
            const cpl = parseInt(document.getElementById('settingCpl').value) || 42;
            const maxLines = parseInt(document.getElementById('settingMaxLines').value) || 2;
            const enableLimits = document.getElementById('toggleLimits').checked;
            
            // Apply limits to a copy of raw data
            if (enableLimits) {
                processedData = applyLimits(rawProcessedData.map(e => ({...e})), cpl, maxLines);
            } else {
                processedData = rawProcessedData.map(e => ({...e}));
            }
            
            // Clear selection since indices may have changed
            selectedEntryIndex = null;
            
            displayPreview(true); // skipScroll to prevent jumping
        }

        // OVERRIDE PARSER FOR SPEAKER EXTRACTION & CC SEPARATION
        async function parseTranscript(content, speakerLabelOverride, timeOffset = 0) {
            const entries = [];
            const blocks = content.split(/\n(?=\[)/);

            // 1. Detect forced CC mode
            let isForcedCC = false;
            if (speakerLabelOverride) {
                const norm = speakerLabelOverride.trim().toLowerCase();
                if (['cc', 'sfx', 'sound', 'sound effects'].includes(norm)) {
                    isForcedCC = true;
                    speakerLabelOverride = '[CC]';
                }
            }

            blocks.forEach(block => {
                const lines = block.trim().split('\n');
                if (!lines[0].startsWith('[')) return;

                const timecodeMatch = lines[0].match(/\[(\d+):(\d+):(\d+):(\d+)\s*-\s*(\d+):(\d+):(\d+):(\d+)\]/);
                if (!timecodeMatch) return;

                let startSec = parseInt(timecodeMatch[1])*3600 + parseInt(timecodeMatch[2])*60 + parseInt(timecodeMatch[3]) + parseInt(timecodeMatch[4])/30;
                let endSec = parseInt(timecodeMatch[5])*3600 + parseInt(timecodeMatch[6])*60 + parseInt(timecodeMatch[7]) + parseInt(timecodeMatch[8])/30;

                startSec += timeOffset;
                endSec += timeOffset;

                const newTimecode = `[${formatTimecode(startSec)} - ${formatTimecode(endSec)}]`;

                let textStart = 1;
                let extractedSpeaker = "Unknown";
                
                // Try to find line starting with "Speaker"
                let foundSpeakerPrefix = false;
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].startsWith('Speaker')) {
                        extractedSpeaker = lines[i].replace('Speaker', '').replace(':', '').trim() || "Speaker";
                        if (extractedSpeaker === "Speaker") extractedSpeaker = lines[i].trim(); 
                        textStart = i + 1;
                        foundSpeakerPrefix = true;
                        break;
                    }
                }

                if (!foundSpeakerPrefix && !speakerLabelOverride && lines.length > 1) {
                    const potentialSpeaker = lines[1].trim();
                    if (potentialSpeaker.length > 0 && potentialSpeaker.length < 50) {
                        extractedSpeaker = potentialSpeaker;
                        textStart = 2;
                    }
                }

                // Process Text Lines
                let rawLines = lines.slice(textStart).map(l => l.trim()).filter(l => l);
                
                // If Forced CC, all lines are CC
                if (isForcedCC) {
                    if (rawLines.length > 0) {
                        entries.push({
                            startSeconds: startSec,
                            endSeconds: endSec,
                            timecode: newTimecode,
                            speaker: '[CC]',
                            text: rawLines.join('\n')
                        });
                    }
                    return;
                }

                // Normal Mode: Split Mixed Lines
                const finalSpeaker = speakerLabelOverride || extractedSpeaker;
                
                rawLines.forEach(line => {
                    // Regex for (text) or [text]
                    // We need to support "Mixed" lines: "(Beep) Hello world" or "Hello (Laughs)"
                    // But also simple "(Beep)"
                    
                    // Strategy: Split by parens capturing delimiter
                    const parts = line.split(/(\([^\)]+\)|\[[^\]]+\])/g).filter(p => p.trim());
                    
                    parts.forEach(part => {
                        const trimmed = part.trim();
                        const isCC = (trimmed.startsWith('(') && trimmed.endsWith(')')) || 
                                     (trimmed.startsWith('[') && trimmed.endsWith(']'));
                                     
                        if (isCC) {
                            entries.push({
                                startSeconds: startSec,
                                endSeconds: endSec,
                                timecode: newTimecode,
                                speaker: '[CC]',
                                text: trimmed
                            });
                        } else {
                            entries.push({
                                startSeconds: startSec,
                                endSeconds: endSec,
                                timecode: newTimecode,
                                speaker: finalSpeaker,
                                text: trimmed
                            });
                        }
                    });
                });
            });
            return entries;
        }

        // EDITING STATE
        let selectedEntryIndex = null;
        let openDropdownIndex = null;

        function displayPreview(skipScroll = false) {
            // Filter based on toggles
            const showSpeakers = document.getElementById('toggleSpeakerNames').checked;
            const showCC = document.getElementById('toggleCC').checked;
            const showTranscription = document.getElementById('toggleTranscription').checked;
            const stripSilence = document.getElementById('toggleStripSilence').checked;
            
            // Helper to check if entry is a silence marker (Silence) or (Blank Audio)
            const isSilence = (entry) => /^\(\s*(silence|blank\s*audio)\s*\)$/i.test(entry.text.trim());
            
            document.getElementById('entryCount').textContent = processedData.length;
            document.getElementById('statEntries').textContent = processedData.length;
            
            // Calculate duration based on mode
            let durationMinutes = 0;
            if (previewMode === 'sequence') {
                // For sequence mode, sum the user-entered durations from the input fields
                let totalSeconds = 0;
                sequenceFiles.forEach(f => {
                    totalSeconds += parseDuration(f.duration);
                });
                durationMinutes = Math.floor(totalSeconds / 60);
            } else {
                // For merge/edit mode, use the last entry's end time
                const lastEntry = processedData[processedData.length - 1];
                durationMinutes = lastEntry ? Math.floor(lastEntry.endSeconds / 60) : 0;
            }
            document.getElementById('statDuration').textContent = durationMinutes + 'm';
            
            // Count unique speakers, excluding [CC]
            const speakerSet = new Set(processedData.filter(e => e.speaker !== '[CC]').map(e => e.speaker));
            document.getElementById('statSpeakers').textContent = speakerSet.size;

            const previewList = document.getElementById('previewList');
            previewList.innerHTML = '';

            // Track last part number for separator insertion in sequence mode
            let lastPartNumber = 0;

            processedData.forEach((entry, index) => {
                const isCC = entry.speaker === '[CC]' || entry.text.startsWith('(') && entry.text.endsWith(')');
                
                // VISIBILITY CHECK
                if (isCC && !showCC) return; // Skip if CC hidden
                if (!isCC && !showTranscription) return; // Skip if Transcription hidden
                if (stripSilence && isSilence(entry)) return; // Skip silence entries if Strip Silence enabled
                
                // ADD PART SEPARATOR for Sequencer mode when entering a new part
                if (previewMode === 'sequence' && entry.partNumber && entry.partNumber !== lastPartNumber) {
                    // Use custom label if available, otherwise fall back to generic "Part N"
                    const labelText = entry.partLabel || `Part ${entry.partNumber}`;
                    
                    // Only show separator if not the first part (visual separator between parts)
                    if (lastPartNumber > 0 || index > 0) {
                        const separator = document.createElement('div');
                        separator.className = 'part-separator';
                        separator.innerHTML = `<span class="part-separator-label">${escapeHtml(labelText)}</span>`;
                        previewList.appendChild(separator);
                    } else if (entry.partNumber === 1) {
                        // For the very first entry, just show a subtle part label
                        const separator = document.createElement('div');
                        separator.className = 'part-separator';
                        separator.style.paddingTop = '0.5rem';
                        separator.innerHTML = `<span class="part-separator-label">${escapeHtml(labelText)}</span>`;
                        previewList.appendChild(separator);
                    }
                    lastPartNumber = entry.partNumber;
                }
                
                const div = document.createElement('div');
                div.className = 'dialogue-entry bg-slate-800 p-3 rounded border border-slate-700';
                div.dataset.index = index;
                
                // Toggle Speaker Visibility
                const speakerStyle = showSpeakers ? '' : 'display: none;';
                
                div.innerHTML = `
                    <!-- Top Action Buttons -->
                    <div class="edit-actions-top">
                        <button class="edit-btn edit-btn-add btn-add-above" title="Add dialogue above">+</button>
                        <button class="edit-btn edit-btn-cc btn-cc-above" title="Add CC above">CC</button>
                    </div>
                    
                    <!-- Entry Content -->
                    <div class="entry-content">
                        <div class="flex items-center justify-between mb-2">
                            <div class="speaker-name-container" style="${speakerStyle}">
                                <button class="speaker-name-btn">${entry.speaker}</button>
                                ${isCC ? '<span class="cc-indicator">CC</span>' : ''}
                            </div>
                            <div class="timing-container timing-display">
                                <span class="text-xs text-slate-500">${entry.timecode}</span>
                            </div>
                        </div>
                        <div class="dialogue-text-container">
                            <p class="dialogue-text-display">${escapeHtml(entry.text)}</p>
                        </div>
                    </div>
                    
                    <!-- Bottom Action Buttons -->
                    <div class="edit-actions-bottom">
                        <div class="edit-actions-left"></div>
                        <div class="edit-actions-center">
                            <button class="edit-btn edit-btn-add btn-add-below" title="Add dialogue below">+</button>
                            <button class="edit-btn edit-btn-cc btn-cc-below" title="Add CC below">CC</button>
                        </div>
                        <div class="edit-actions-right">
                            <button class="edit-btn edit-btn-save btn-save" title="Save changes">âœ“</button>
                            <button class="edit-btn edit-btn-delete btn-delete" title="Delete entry"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                        </div>
                    </div>
                `;
                
                // Click handler for selection
                div.addEventListener('click', (e) => {
                    // Don't select if clicking on buttons or inputs
                    if (e.target.closest('.edit-btn') || e.target.closest('.speaker-dropdown') || 
                        e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                        return;
                    }
                    selectEntry(index);
                });
                
                // Speaker dropdown handler
                const speakerBtn = div.querySelector('.speaker-name-btn');
                speakerBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (selectedEntryIndex === index) {
                        toggleSpeakerDropdown(index, speakerBtn);
                    }
                });
                
                // Add Above button
                div.querySelector('.btn-add-above').addEventListener('click', (e) => {
                    e.stopPropagation();
                    addEntryAbove(index, false);
                });
                
                // Add CC Above button
                div.querySelector('.btn-cc-above').addEventListener('click', (e) => {
                    e.stopPropagation();
                    addEntryAbove(index, true);
                });
                
                // Add Below button
                div.querySelector('.btn-add-below').addEventListener('click', (e) => {
                    e.stopPropagation();
                    addEntryBelow(index, false);
                });
                
                // Add CC Below button
                div.querySelector('.btn-cc-below').addEventListener('click', (e) => {
                    e.stopPropagation();
                    addEntryBelow(index, true);
                });
                
                // Save button
                div.querySelector('.btn-save').addEventListener('click', (e) => {
                    e.stopPropagation();
                    saveEntryChanges(index);
                });
                
                // Delete button
                div.querySelector('.btn-delete').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteEntry(index);
                });
                
                previewList.appendChild(div);
            });

            document.getElementById('previewSection').classList.remove('hidden');
            // Only scroll to preview on initial display, not on toggle updates
            if (!skipScroll) {
                document.getElementById('previewSection').scrollIntoView({ behavior: 'smooth' });
            }
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', closeAllDropdowns);
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function selectEntry(index) {
            // Save previous entry if one was selected
            if (selectedEntryIndex !== null && selectedEntryIndex !== index) {
                saveEntryChanges(selectedEntryIndex, true);
                deselectEntry(selectedEntryIndex);
            }
            
            // Toggle if clicking same entry
            if (selectedEntryIndex === index) {
                saveEntryChanges(index, true);
                deselectEntry(index);
                return;
            }
            
            selectedEntryIndex = index;
            const entryEl = document.querySelector(`[data-index="${index}"]`);
            if (!entryEl) return;
            
            entryEl.classList.add('selected');
            enableEditing(entryEl, index);
        }
        
        function deselectEntry(index) {
            const entryEl = document.querySelector(`[data-index="${index}"]`);
            if (!entryEl) return;
            
            entryEl.classList.remove('selected');
            disableEditing(entryEl, index);
            selectedEntryIndex = null;
            closeAllDropdowns();
        }
        
        function enableEditing(entryEl, index) {
            const entry = processedData[index];
            
            // Replace text display with textarea
            const textContainer = entryEl.querySelector('.dialogue-text-container');
            textContainer.innerHTML = `<textarea class="edit-text-input">${entry.text}</textarea>`;
            
            // Add Ctrl+Enter to save and Escape to cancel for textarea
            const textInput = textContainer.querySelector('.edit-text-input');
            textInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    saveEntryChanges(index);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    deselectEntry(index);
                }
            });
            
            // Replace timing display with editable inputs
            const timingContainer = entryEl.querySelector('.timing-display');
            const fps = getFramerate();
            const formatLabel = fps === null ? 'HH:MM:SS' : (fps > 60 ? 'HH:MM:SS:FFF' : 'HH:MM:SS:FF');
            const inputWidth = fps === null ? '80px' : '100px';
            
            timingContainer.innerHTML = `
                <div class="timing-input-group">
                    <span class="timing-format-label">${formatLabel}</span>
                    <input type="text" class="edit-timing-input edit-timing-start" style="width: ${inputWidth}" value="${formatEditableTimecode(entry.startSeconds)}" />
                </div>
                <span class="timing-separator">-</span>
                <div class="timing-input-group">
                    <span class="timing-format-label">${formatLabel}</span>
                    <input type="text" class="edit-timing-input edit-timing-end" style="width: ${inputWidth}" value="${formatEditableTimecode(entry.endSeconds)}" />
                </div>
            `;
            
            // Setup enhanced timing input behavior for both start and end inputs
            const startInput = timingContainer.querySelector('.edit-timing-start');
            const endInput = timingContainer.querySelector('.edit-timing-end');
            
            setupTimingInput(startInput, () => validateTimingPair(startInput, endInput));
            setupTimingInput(endInput, () => validateTimingPair(startInput, endInput));
            
            // Add Enter to confirm timing and Escape to cancel for timing inputs
            [startInput, endInput].forEach(input => {
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        e.target.blur(); // Just confirm the timing value, stay in edit mode
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        deselectEntry(index);
                    }
                });
            });
            
            // Initial validation
            validateTimingPair(startInput, endInput);
        }
        
        // Validate timing pair and highlight if invalid
        function validateTimingPair(startInput, endInput) {
            const startSeconds = parseEditableTimecode(startInput.value);
            const endSeconds = parseEditableTimecode(endInput.value);
            
            if (endSeconds <= startSeconds) {
                startInput.classList.add('invalid');
                endInput.classList.add('invalid');
            } else {
                startInput.classList.remove('invalid');
                endInput.classList.remove('invalid');
            }
        }
        
        // Setup sequencer-like input behavior for timing inputs (dynamic format based on framerate)
        function setupTimingInput(input, onChangeCallback) {
            const fps = getFramerate();
            const hasFrames = fps !== null;
            const frameDigits = hasFrames ? (fps > 60 ? 3 : 2) : 0;
            const maxFieldIndex = hasFrames ? 3 : 2; // 3 or 4 fields
            
            // STATE: Track which field is being edited and digit position within field
            let activeFieldIndex = 0;  // 0=hours, 1=minutes, 2=seconds, 3=frames (if enabled)
            let digitPosition = 0;     // Current digit position within the field
            let pendingDigits = '';    // Accumulated digits for current field
            
            // Field selection ranges - dynamic based on framerate
            const ranges = hasFrames 
                ? (frameDigits === 3 
                    ? [[0, 2], [3, 5], [6, 8], [9, 12]]   // HH:MM:SS:FFF
                    : [[0, 2], [3, 5], [6, 8], [9, 11]])  // HH:MM:SS:FF
                : [[0, 2], [3, 5], [6, 8]];               // HH:MM:SS
            
            // Helper to select a specific field
            function selectField(fieldIndex) {
                if (fieldIndex > maxFieldIndex) fieldIndex = maxFieldIndex;
                const [start, end] = ranges[fieldIndex];
                input.setSelectionRange(start, end);
                activeFieldIndex = fieldIndex;
                digitPosition = 0;  // Reset digit position when field is selected
                pendingDigits = ''; // Clear pending digits
            }
            
            // Get field index from cursor position (for clicks)
            function getFieldFromPosition(pos) {
                if (pos <= 2) return 0;  // Hours (0-2)
                if (pos <= 5) return 1;  // Minutes (3-5)
                if (pos <= 8) return 2;  // Seconds (6-8)
                if (hasFrames) return 3; // Frames
                return 2; // No frames, stay on seconds
            }
            
            // Parse current value into array [hours, minutes, seconds, frames?]
            function parseValue(value) {
                const parts = value.split(':');
                const result = [
                    (parts[0] || '00').padStart(2, '0'),
                    (parts[1] || '00').padStart(2, '0'),
                    (parts[2] || '00').padStart(2, '0')
                ];
                if (hasFrames) {
                    result.push((parts[3] || '0'.repeat(frameDigits)).padStart(frameDigits, '0'));
                }
                return result;
            }
            
            // Format array back to timecode string
            function formatValue(parts) {
                let result = `${parts[0].padStart(2, '0')}:${parts[1].padStart(2, '0')}:${parts[2].padStart(2, '0')}`;
                if (hasFrames && parts[3]) {
                    result += `:${parts[3].padStart(frameDigits, '0')}`;
                }
                return result;
            }
            
            // Get max value for a field
            function _getMaxValue(fieldIndex) {
                if (fieldIndex === 1 || fieldIndex === 2) return 59; // Minutes/Seconds
                if (fieldIndex === 3 && hasFrames) {
                    return Math.ceil(fps) - 1; // Max frame is fps - 1
                }
                return 99; // Hours
            }
            
            // Get number of digits for a field
            function _getFieldDigits(fieldIndex) {
                if (fieldIndex === 3 && hasFrames) return frameDigits;
                return 2;
            }
            
            input.addEventListener('keydown', (e) => {
                // Allow tab to move to next input
                if (e.key === 'Tab') {
                    digitPosition = 0;
                    pendingDigits = '';
                    return;
                }
                
                // Allow Ctrl/Cmd shortcuts
                if (e.ctrlKey || e.metaKey) {
                    return;
                }
                
                // Arrow left - move to previous field
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (activeFieldIndex > 0) {
                        selectField(activeFieldIndex - 1);
                    }
                    return;
                }
                
                // Arrow right - move to next field
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (activeFieldIndex < 3) {
                        selectField(activeFieldIndex + 1);
                    }
                    return;
                }
                
                // Arrow up - increment current field
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const parts = parseValue(input.value);
                    let val = parseInt(parts[activeFieldIndex]);
                    const maxVal = getMaxValue(activeFieldIndex);
                    val = Math.min(val + 1, maxVal);
                    parts[activeFieldIndex] = String(val).padStart(2, '0');
                    input.value = formatValue(parts);
                    selectField(activeFieldIndex);
                    if (onChangeCallback) onChangeCallback();
                    return;
                }
                
                // Arrow down - decrement current field
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const parts = parseValue(input.value);
                    let val = parseInt(parts[activeFieldIndex]);
                    val = Math.max(val - 1, 0);
                    parts[activeFieldIndex] = String(val).padStart(2, '0');
                    input.value = formatValue(parts);
                    selectField(activeFieldIndex);
                    if (onChangeCallback) onChangeCallback();
                    return;
                }
                
                // Home - select hours
                if (e.key === 'Home') {
                    e.preventDefault();
                    selectField(0);
                    return;
                }
                
                // End - select last field
                if (e.key === 'End') {
                    e.preventDefault();
                    selectField(maxFieldIndex);
                    return;
                }
                
                const parts = parseValue(input.value);
                
                // Backspace - delete one digit at a time
                if (e.key === 'Backspace' || e.key === 'Delete') {
                    e.preventDefault();
                    
                    // If we were in the middle of entering digits, just clear and stay on this field
                    if (digitPosition > 0) {
                        const zeroVal = _getFieldDigits(activeFieldIndex) === 3 ? '000' : '00';
                        parts[activeFieldIndex] = zeroVal;
                        input.value = formatValue(parts);
                        digitPosition = 0;
                        pendingDigits = '';
                        selectField(activeFieldIndex);
                        if (onChangeCallback) onChangeCallback();
                        return;
                    }
                    
                    // Check if already zero before attempting deletion
                    const zeroVal = _getFieldDigits(activeFieldIndex) === 3 ? '000' : '00';
                    const wasAlreadyZero = parts[activeFieldIndex] === zeroVal;
                    
                    if (wasAlreadyZero && activeFieldIndex > 0) {
                        // Already at zero, move to previous field
                        selectField(activeFieldIndex - 1);
                    } else if (!wasAlreadyZero) {
                        // Shift digits right (remove rightmost, pad left with 0)
                        const currentValue = parts[activeFieldIndex];
                        const shifted = '0' + currentValue.slice(0, -1);
                        parts[activeFieldIndex] = shifted;
                        
                        input.value = formatValue(parts);
                        if (onChangeCallback) onChangeCallback();
                        
                        // Check if we just made it zero - move to previous field
                        if (parts[activeFieldIndex] === zeroVal && activeFieldIndex > 0) {
                            selectField(activeFieldIndex - 1);
                        } else {
                            selectField(activeFieldIndex);
                        }
                    } else {
                        // Already zero but on first field (hours), just stay
                        selectField(activeFieldIndex);
                    }
                    return;
                }
                
                // Handle digit input
                if (/[0-9]/.test(e.key)) {
                    e.preventDefault();
                    
                    const maxDigits = _getFieldDigits(activeFieldIndex);
                    let fieldValue;
                    let shouldAdvance = false;
                    
                    // Add digit to pending
                    pendingDigits += e.key;
                    digitPosition++;
                    
                    if (digitPosition < maxDigits) {
                        // Still building the field value
                        fieldValue = pendingDigits.padStart(maxDigits, '0');
                    } else {
                        // Field is complete
                        fieldValue = pendingDigits.slice(-maxDigits); // Take last N digits
                        const val = parseInt(fieldValue);
                        const maxVal = _getMaxValue(activeFieldIndex);
                        
                        // Block invalid values
                        if (val > maxVal) {
                            // Invalid input - revert to previous digits minus last
                            pendingDigits = pendingDigits.slice(0, -1);
                            digitPosition--;
                            return;
                        }
                        
                        shouldAdvance = true;
                    }
                    
                    parts[activeFieldIndex] = fieldValue;
                    input.value = formatValue(parts);
                    if (onChangeCallback) onChangeCallback();
                    
                    // Auto-advance to next field if appropriate
                    if (shouldAdvance && activeFieldIndex < maxFieldIndex) {
                        selectField(activeFieldIndex + 1);
                    } else if (shouldAdvance) {
                        // On last field after completing digits, re-select it
                        selectField(activeFieldIndex);
                    } else {
                        // Still entering digits, position cursor BEFORE the next digit slot
                        const [start, end] = ranges[activeFieldIndex];
                        // Position cursor at the next digit to be entered
                        const cursorPos = start + digitPosition;
                        input.setSelectionRange(cursorPos, cursorPos);
                    }
                    return;
                }
                
                // Allow Enter and Escape to bubble up to parent handlers
                if (e.key === 'Enter' || e.key === 'Escape') {
                    return;
                }
                
                // Block all other keys
                e.preventDefault();
            });
            
            // Click to select the field that was clicked
            input.addEventListener('click', (e) => {
                const field = getFieldFromPosition(e.target.selectionStart);
                selectField(field);
            });
            
            // Focus to select hours by default
            input.addEventListener('focus', (e) => {
                selectField(0);
            });
            
            // Prevent pasting
            input.addEventListener('paste', (e) => {
                e.preventDefault();
            });
        }
        
        function disableEditing(entryEl, index) {
            const entry = processedData[index];
            
            // Restore text display
            const textContainer = entryEl.querySelector('.dialogue-text-container');
            textContainer.innerHTML = `<p class="dialogue-text-display">${escapeHtml(entry.text)}</p>`;
            
            // Restore timing display
            const timingContainer = entryEl.querySelector('.timing-display');
            timingContainer.innerHTML = `<span class="text-xs text-slate-500">${entry.timecode}</span>`;
        }
        
        // Get framerate based on current mode's file(s)
        // Returns null if "ignore", otherwise returns fps number
        function getFramerate() {
            if (currentMode === 'edit') {
                const editFileEl = document.getElementById('file-edit');
                const select = editFileEl?.querySelector('.framerate-select');
                const customInput = editFileEl?.querySelector('.framerate-custom');
                const val = select?.value || 'ignore';
                if (val === 'ignore') return null;
                if (val === 'custom') {
                    const customVal = parseFloat(customInput?.value);
                    return customVal > 0 ? customVal : null;
                }
                return parseFloat(val);
            } else if (currentMode === 'merge') {
                // Use first file's framerate (or could use most common)
                const firstFile = mergeFiles[0];
                const val = firstFile?.framerate || 'ignore';
                return val === 'ignore' ? null : parseFloat(val);
            } else if (currentMode === 'sequence') {
                // Use first file's framerate
                const firstFile = sequenceFiles[0];
                const val = firstFile?.framerate || 'ignore';
                return val === 'ignore' ? null : parseFloat(val);
            }
            return null; // Default: ignore frames
        }
        
        // Get number of digits for frame display based on framerate
        function getFrameDigits(fps) {
            if (fps === null) return 0; // No frames
            return fps > 60 ? 3 : 2; // 3 digits for high framerates, 2 for standard
        }
        
        function formatEditableTimecode(seconds) {
            const fps = getFramerate();
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            
            if (fps === null) {
                // No frames - just HH:MM:SS
                return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
            }
            
            const ff = Math.floor((seconds % 1) * fps);
            const frameDigits = getFrameDigits(fps);
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}:${String(ff).padStart(frameDigits,'0')}`;
        }
        
        function parseEditableTimecode(timecodeStr) {
            const fps = getFramerate();
            const parts = timecodeStr.split(':').map(Number);
            
            if (fps === null || parts.length === 3) {
                // No frames - just HH:MM:SS
                if (parts.length >= 3) {
                    return parts[0] * 3600 + parts[1] * 60 + parts[2];
                }
            } else if (parts.length === 4) {
                return parts[0] * 3600 + parts[1] * 60 + parts[2] + parts[3] / fps;
            }
            return 0;
        }
        
        function toggleSpeakerDropdown(index, speakerBtn) {
            const container = speakerBtn.closest('.speaker-name-container');
            const existingDropdown = container.querySelector('.speaker-dropdown');
            
            if (existingDropdown) {
                existingDropdown.remove();
                openDropdownIndex = null;
                return;
            }
            
            closeAllDropdowns();
            
            // Get unique speakers
            const speakers = [...new Set(processedData.map(e => e.speaker))];
            const currentSpeaker = processedData[index].speaker;
            
            const dropdown = document.createElement('div');
            dropdown.className = 'speaker-dropdown';
            dropdown.innerHTML = `
                ${speakers.map(s => `
                    <div class="speaker-option ${s === currentSpeaker ? 'selected' : ''}" data-speaker="${escapeHtml(s)}">${escapeHtml(s)}</div>
                `).join('')}
                <div class="speaker-option custom-option" data-custom="true">+ Custom Speaker...</div>
                <div class="speaker-option rename-option" data-rename="true">âœ Rename "${escapeHtml(currentSpeaker)}" (All)</div>
            `;
            
            // Add click handlers for speaker options
            dropdown.querySelectorAll('.speaker-option:not(.custom-option):not(.rename-option)').forEach(opt => {
                opt.addEventListener('click', (e) => {
                    e.stopPropagation();
                    setSpeaker(index, opt.dataset.speaker);
                    closeAllDropdowns();
                });
            });
            
            // Custom speaker option
            dropdown.querySelector('.custom-option').addEventListener('click', (e) => {
                e.stopPropagation();
                showCustomSpeakerInput(dropdown, index);
            });
            
            // Rename speaker option
            dropdown.querySelector('.rename-option').addEventListener('click', (e) => {
                e.stopPropagation();
                showRenameSpeakerInput(dropdown, index, currentSpeaker);
            });
            
            container.appendChild(dropdown);
            openDropdownIndex = index;
        }
        
        function showCustomSpeakerInput(dropdown, index) {
            const customOption = dropdown.querySelector('.custom-option');
            customOption.remove();
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'speaker-custom-input';
            input.placeholder = 'Enter speaker name...';
            dropdown.appendChild(input);
            input.focus();
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && input.value.trim()) {
                    setSpeaker(index, input.value.trim());
                    closeAllDropdowns();
                }
                if (e.key === 'Escape') {
                    closeAllDropdowns();
                }
            });
            
            input.addEventListener('click', (e) => e.stopPropagation());
        }
        
        function showRenameSpeakerInput(dropdown, index, oldSpeaker) {
            // Remove the rename option and custom option, show input
            const renameOption = dropdown.querySelector('.rename-option');
            const customOption = dropdown.querySelector('.custom-option');
            if (renameOption) renameOption.remove();
            if (customOption) customOption.remove();
            
            const inputContainer = document.createElement('div');
            inputContainer.style.cssText = 'padding: 8px 10px; border-top: 1px solid #475569;';
            inputContainer.innerHTML = `
                <div style="color: #fbbf24; font-size: 0.75rem; margin-bottom: 6px;">Rename all "${escapeHtml(oldSpeaker)}" to:</div>
            `;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'speaker-custom-input';
            input.style.cssText = 'margin-top: 0; border-top: none;';
            input.placeholder = 'Enter new name...';
            input.value = oldSpeaker === '[CC]' ? '' : oldSpeaker; // Pre-fill with current name for easy editing
            inputContainer.appendChild(input);
            dropdown.appendChild(inputContainer);
            input.focus();
            input.select();
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && input.value.trim()) {
                    renameSpeaker(oldSpeaker, input.value.trim());
                    closeAllDropdowns();
                }
                if (e.key === 'Escape') {
                    closeAllDropdowns();
                }
            });
            
            input.addEventListener('click', (e) => e.stopPropagation());
        }
        
        function renameSpeaker(oldSpeaker, newSpeaker) {
            if (oldSpeaker === newSpeaker) return;
            
            let changedCount = 0;
            
            // Update all entries with the old speaker name in processedData
            processedData.forEach((entry, idx) => {
                if (entry.speaker === oldSpeaker) {
                    entry.speaker = newSpeaker;
                    changedCount++;
                    
                    // Update the DOM element if it exists
                    const entryEl = document.querySelector(`[data-index="${idx}"]`);
                    if (entryEl) {
                        const speakerBtn = entryEl.querySelector('.speaker-name-btn');
                        if (speakerBtn) {
                            speakerBtn.textContent = newSpeaker;
                        }
                        
                        // Update CC indicator
                        const isCC = newSpeaker === '[CC]';
                        const existingIndicator = entryEl.querySelector('.cc-indicator');
                        if (isCC && !existingIndicator) {
                            speakerBtn.insertAdjacentHTML('afterend', '<span class="cc-indicator">CC</span>');
                        } else if (!isCC && existingIndicator) {
                            existingIndicator.remove();
                        }
                    }
                }
            });
            
            // SYNC TO RAW DATA: Update rawProcessedData as well
            if (rawProcessedData) {
                rawProcessedData.forEach(entry => {
                    if (entry.speaker === oldSpeaker) {
                        entry.speaker = newSpeaker;
                    }
                });
            }
            
            // Update stats - exclude [CC] from speaker count
            const speakerSet = new Set(processedData.filter(e => e.speaker !== '[CC]').map(e => e.speaker));
            document.getElementById('statSpeakers').textContent = speakerSet.size;
            
            console.log(`Renamed "${oldSpeaker}" to "${newSpeaker}" in ${changedCount} entries.`);
        }
        
        function setSpeaker(index, speaker) {
            const entry = processedData[index];
            entry.speaker = speaker;
            
            // SYNC TO RAW DATA
            if (entry.rawId !== undefined && rawProcessedData) {
                const rawEntry = rawProcessedData.find(r => r.rawId === entry.rawId);
                if (rawEntry) {
                    rawEntry.speaker = speaker;
                }
            }
            
            const entryEl = document.querySelector(`[data-index="${index}"]`);
            if (entryEl) {
                const speakerBtn = entryEl.querySelector('.speaker-name-btn');
                speakerBtn.textContent = speaker;
                
                // Update CC indicator
                const isCC = speaker === '[CC]';
                const existingIndicator = entryEl.querySelector('.cc-indicator');
                if (isCC && !existingIndicator) {
                    speakerBtn.insertAdjacentHTML('afterend', '<span class="cc-indicator">CC</span>');
                } else if (!isCC && existingIndicator) {
                    existingIndicator.remove();
                }
            }
            
            // Update stats - exclude [CC] from speaker count
            const speakerSet = new Set(processedData.filter(e => e.speaker !== '[CC]').map(e => e.speaker));
            document.getElementById('statSpeakers').textContent = speakerSet.size;
        }
        
        function closeAllDropdowns() {
            document.querySelectorAll('.speaker-dropdown').forEach(d => d.remove());
            openDropdownIndex = null;
        }
        
        function addEntryAbove(index, isCC = false) {
            const refEntry = processedData[index];
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 1.0;
            const desiredDuration = Math.max(minDuration, 1.0); // At least 1 second for new entry
            
            // Check available gap
            let availableGap = refEntry.startSeconds; // Default: from start of timeline
            let prevEntry = null;
            
            if (index > 0) {
                prevEntry = processedData[index - 1];
                availableGap = refEntry.startSeconds - prevEntry.endSeconds;
            }
            
            let startTime, endTime;
            
            if (availableGap >= desiredDuration) {
                // Enough gap - place just before reference entry
                endTime = refEntry.startSeconds;
                startTime = endTime - Math.min(availableGap, desiredDuration);
            } else {
                // Not enough gap - need to nudge surrounding entries
                const neededTime = desiredDuration - Math.max(0, availableGap);
                
                // Split the nudge equally between prev entry (shorten end) and ref entry (shift start forward)
                let nudgePrev = 0;
                let nudgeRef = 0;
                
                if (prevEntry && index > 0) {
                    // Can we shorten the previous entry's end?
                    const prevDuration = prevEntry.endSeconds - prevEntry.startSeconds;
                    const prevCanGive = Math.max(0, prevDuration - minDuration);
                    
                    // Can we push the reference entry's start later?
                    const refDuration = refEntry.endSeconds - refEntry.startSeconds;
                    const refCanGive = Math.max(0, refDuration - minDuration);
                    
                    // Split needed time equally, but respect limits
                    const halfNeeded = neededTime / 2;
                    nudgePrev = Math.min(halfNeeded, prevCanGive);
                    nudgeRef = Math.min(halfNeeded, refCanGive);
                    
                    // If one side can't give enough, try to take more from the other
                    if (nudgePrev < halfNeeded && nudgeRef < refCanGive) {
                        nudgeRef = Math.min(neededTime - nudgePrev, refCanGive);
                    } else if (nudgeRef < halfNeeded && nudgePrev < prevCanGive) {
                        nudgePrev = Math.min(neededTime - nudgeRef, prevCanGive);
                    }
                    
                    // Apply nudges to surrounding entries
                    if (nudgePrev > 0) {
                        prevEntry.endSeconds -= nudgePrev;
                        prevEntry.timecode = `[${formatTimecode(prevEntry.startSeconds)} - ${formatTimecode(prevEntry.endSeconds)}]`;
                    }
                    if (nudgeRef > 0) {
                        refEntry.startSeconds += nudgeRef;
                        refEntry.timecode = `[${formatTimecode(refEntry.startSeconds)} - ${formatTimecode(refEntry.endSeconds)}]`;
                    }
                } else {
                    // No previous entry - only nudge the reference entry forward
                    const refDuration = refEntry.endSeconds - refEntry.startSeconds;
                    const refCanGive = Math.max(0, refDuration - minDuration);
                    nudgeRef = Math.min(neededTime, refCanGive);
                    
                    if (nudgeRef > 0) {
                        refEntry.startSeconds += nudgeRef;
                        refEntry.timecode = `[${formatTimecode(refEntry.startSeconds)} - ${formatTimecode(refEntry.endSeconds)}]`;
                    }
                }
                
                // Calculate new entry timing after nudges
                startTime = prevEntry ? prevEntry.endSeconds : Math.max(0, refEntry.startSeconds - desiredDuration);
                endTime = refEntry.startSeconds;
                
                // Ensure we still have at least minimum duration
                if (endTime - startTime < minDuration) {
                    startTime = Math.max(0, endTime - minDuration);
                }
            }
            
            const newEntry = {
                startSeconds: startTime,
                endSeconds: endTime,
                timecode: `[${formatTimecode(startTime)} - ${formatTimecode(endTime)}]`,
                speaker: isCC ? '[CC]' : refEntry.speaker,
                text: isCC ? '(Enter description)' : 'New dialogue',
                rawId: rawProcessedData ? Math.max(...rawProcessedData.map(e => e.rawId || 0)) + 1 : 0
            };
            
            // Add to rawProcessedData to survive limit changes
            if (rawProcessedData) {
                // Find insert position based on timing
                const rawInsertIdx = rawProcessedData.findIndex(e => e.startSeconds >= startTime);
                if (rawInsertIdx >= 0) {
                    rawProcessedData.splice(rawInsertIdx, 0, {...newEntry});
                } else {
                    rawProcessedData.push({...newEntry});
                }
            }
            
            processedData.splice(index, 0, newEntry);
            selectedEntryIndex = null;
            displayPreview();
            
            // Select the new entry for immediate editing
            setTimeout(() => selectEntry(index), 50);
        }
        
        function addEntryBelow(index, isCC = false) {
            const refEntry = processedData[index];
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 1.0;
            const desiredDuration = Math.max(minDuration, 1.0); // At least 1 second for new entry
            
            // Check available gap
            let availableGap = Infinity; // Default: no limit (end of timeline)
            let nextEntry = null;
            
            if (index < processedData.length - 1) {
                nextEntry = processedData[index + 1];
                availableGap = nextEntry.startSeconds - refEntry.endSeconds;
            }
            
            let startTime, endTime;
            
            if (availableGap >= desiredDuration) {
                // Enough gap - place just after reference entry
                startTime = refEntry.endSeconds;
                endTime = startTime + Math.min(availableGap === Infinity ? desiredDuration : availableGap, desiredDuration);
            } else {
                // Not enough gap - need to nudge surrounding entries
                const neededTime = desiredDuration - Math.max(0, availableGap);
                
                // Split the nudge equally between ref entry (shorten end) and next entry (shift start later)
                let nudgeRef = 0;
                let nudgeNext = 0;
                
                if (nextEntry) {
                    // Can we shorten the reference entry's end?
                    const refDuration = refEntry.endSeconds - refEntry.startSeconds;
                    const refCanGive = Math.max(0, refDuration - minDuration);
                    
                    // Can we push the next entry's start later?
                    const nextDuration = nextEntry.endSeconds - nextEntry.startSeconds;
                    const nextCanGive = Math.max(0, nextDuration - minDuration);
                    
                    // Split needed time equally, but respect limits
                    const halfNeeded = neededTime / 2;
                    nudgeRef = Math.min(halfNeeded, refCanGive);
                    nudgeNext = Math.min(halfNeeded, nextCanGive);
                    
                    // If one side can't give enough, try to take more from the other
                    if (nudgeRef < halfNeeded && nudgeNext < nextCanGive) {
                        nudgeNext = Math.min(neededTime - nudgeRef, nextCanGive);
                    } else if (nudgeNext < halfNeeded && nudgeRef < refCanGive) {
                        nudgeRef = Math.min(neededTime - nudgeNext, refCanGive);
                    }
                    
                    // Apply nudges to surrounding entries
                    if (nudgeRef > 0) {
                        refEntry.endSeconds -= nudgeRef;
                        refEntry.timecode = `[${formatTimecode(refEntry.startSeconds)} - ${formatTimecode(refEntry.endSeconds)}]`;
                    }
                    if (nudgeNext > 0) {
                        nextEntry.startSeconds += nudgeNext;
                        nextEntry.timecode = `[${formatTimecode(nextEntry.startSeconds)} - ${formatTimecode(nextEntry.endSeconds)}]`;
                    }
                } else {
                    // No next entry - only nudge the reference entry's end back
                    const refDuration = refEntry.endSeconds - refEntry.startSeconds;
                    const refCanGive = Math.max(0, refDuration - minDuration);
                    nudgeRef = Math.min(neededTime, refCanGive);
                    
                    if (nudgeRef > 0) {
                        refEntry.endSeconds -= nudgeRef;
                        refEntry.timecode = `[${formatTimecode(refEntry.startSeconds)} - ${formatTimecode(refEntry.endSeconds)}]`;
                    }
                }
                
                // Calculate new entry timing after nudges
                startTime = refEntry.endSeconds;
                endTime = nextEntry ? nextEntry.startSeconds : startTime + desiredDuration;
                
                // Ensure we still have at least minimum duration
                if (endTime - startTime < minDuration) {
                    endTime = startTime + minDuration;
                }
            }
            
            const newEntry = {
                startSeconds: startTime,
                endSeconds: endTime,
                timecode: `[${formatTimecode(startTime)} - ${formatTimecode(endTime)}]`,
                speaker: isCC ? '[CC]' : refEntry.speaker,
                text: isCC ? '(Enter description)' : 'New dialogue',
                rawId: rawProcessedData ? Math.max(...rawProcessedData.map(e => e.rawId || 0)) + 1 : 0
            };
            
            // Add to rawProcessedData to survive limit changes
            if (rawProcessedData) {
                const rawInsertIdx = rawProcessedData.findIndex(e => e.startSeconds >= startTime);
                if (rawInsertIdx >= 0) {
                    rawProcessedData.splice(rawInsertIdx, 0, {...newEntry});
                } else {
                    rawProcessedData.push({...newEntry});
                }
            }
            
            processedData.splice(index + 1, 0, newEntry);
            selectedEntryIndex = null;
            displayPreview();
            
            // Select the new entry for immediate editing
            setTimeout(() => selectEntry(index + 1), 50);
        }
        
        function deleteEntry(index) {
            if (processedData.length <= 1) {
                alert("Cannot delete the last entry.");
                return;
            }
            
            // Get the entry's rawId before removing
            const entry = processedData[index];
            
            // Remove from rawProcessedData to persist deletion through limit changes
            if (entry.rawId !== undefined && rawProcessedData) {
                const rawIdx = rawProcessedData.findIndex(r => r.rawId === entry.rawId);
                if (rawIdx >= 0) {
                    rawProcessedData.splice(rawIdx, 1);
                }
            }
            
            // Remove from display data
            processedData.splice(index, 1);
            selectedEntryIndex = null;
            
            // Re-render the preview
            displayPreview();
            
            // Update entry count display
            document.getElementById('entryCount').textContent = processedData.length;
        }
        
        function saveEntryChanges(index, silent = false) {
            const entryEl = document.querySelector(`[data-index="${index}"]`);
            if (!entryEl) return;
            
            const entry = processedData[index];
            
            // Get edited text
            const textInput = entryEl.querySelector('.edit-text-input');
            if (textInput) {
                entry.text = textInput.value;
            }
            
            // Get edited timing
            const startInput = entryEl.querySelector('.edit-timing-start');
            const endInput = entryEl.querySelector('.edit-timing-end');
            let timingChanged = false;
            if (startInput && endInput) {
                const newStartSeconds = parseEditableTimecode(startInput.value);
                const newEndSeconds = parseEditableTimecode(endInput.value);
                
                if (newStartSeconds !== entry.startSeconds || newEndSeconds !== entry.endSeconds) {
                    timingChanged = true;
                }
                
                entry.startSeconds = newStartSeconds;
                entry.endSeconds = newEndSeconds;
                entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
            }
            
            // SYNC TO RAW DATA: Find the raw entry and update it
            // This ensures edits survive when limits are re-applied
            if (entry.rawId !== undefined && rawProcessedData) {
                const rawEntry = rawProcessedData.find(r => r.rawId === entry.rawId);
                if (rawEntry) {
                    rawEntry.text = entry.text;
                    rawEntry.speaker = entry.speaker;
                    rawEntry.startSeconds = entry.startSeconds;
                    rawEntry.endSeconds = entry.endSeconds;
                    rawEntry.timecode = entry.timecode;
                }
            }
            
            // Update stats
            document.getElementById('statEntries').textContent = processedData.length;
            
            // Calculate duration based on mode
            let durationMinutes = 0;
            if (previewMode === 'sequence') {
                let totalSeconds = 0;
                sequenceFiles.forEach(f => {
                    totalSeconds += parseDuration(f.duration);
                });
                durationMinutes = Math.floor(totalSeconds / 60);
            } else {
                const lastEntry = processedData[processedData.length - 1];
                durationMinutes = lastEntry ? Math.floor(lastEntry.endSeconds / 60) : 0;
            }
            document.getElementById('statDuration').textContent = durationMinutes + 'm';
            
            // If timing changed, re-sort entries by start time and refresh preview
            if (timingChanged) {
                selectedEntryIndex = null;
                processedData.sort((a, b) => a.startSeconds - b.startSeconds);
                // Also re-sort raw data to keep them in sync
                if (rawProcessedData) {
                    rawProcessedData.sort((a, b) => a.startSeconds - b.startSeconds);
                }
                displayPreview();
                return; // displayPreview handles everything, no need to deselect
            }
            
            if (!silent) {
                deselectEntry(index);
            }
        }

        // EXPORTS
        function download(content, filename, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        document.getElementById('downloadTxtBtn').addEventListener('click', () => {
            if (!processedData) return;
            const showSpeakers = document.getElementById('toggleSpeakerNames').checked;
            const showCC = document.getElementById('toggleCC').checked;
            const stripSilence = document.getElementById('toggleStripSilence').checked;
            
            // STEP 1: Strip (Silence) and (Blank Audio) entries if enabled
            const isSilence = (entry) => /^\(\s*(silence|blank\s*audio)\s*\)$/i.test(entry.text.trim());
            const noSilenceData = stripSilence ? processedData.filter(e => !isSilence(e)) : processedData;
            
            // STEP 2: Filter based on visibility toggles
            const showTranscription = document.getElementById('toggleTranscription').checked;
            const isCC = (entry) => entry.speaker === '[CC]' || (entry.text.startsWith('(') && entry.text.endsWith(')'));
            
            const filteredData = noSilenceData.filter(e => {
                if (isCC(e) && !showCC) return false;
                if (!isCC(e) && !showTranscription) return false;
                return true;
            });

            
            // STEP 3: Clone and apply timing corrections (linearization + min duration)
            const txtData = filteredData.map(entry => ({ ...entry }));
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 0;
            
            let lastEnd = 0;
            txtData.forEach((entry) => {
                // Fix overlaps
                if (entry.startSeconds < lastEnd) {
                    entry.startSeconds = lastEnd;
                }
                // Apply minimum duration
                if (minDuration > 0) {
                    const currentDuration = entry.endSeconds - entry.startSeconds;
                    if (currentDuration < minDuration) {
                        entry.endSeconds = entry.startSeconds + minDuration;
                    }
                } else {
                    if (entry.startSeconds >= entry.endSeconds) {
                        entry.endSeconds = entry.startSeconds + 0.1;
                    }
                }
                // Update timecode string
                entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
                lastEnd = entry.endSeconds;
            });
            
            let content = '';
            txtData.forEach(entry => {
                content += `${entry.timecode}\n`;
                if (showSpeakers) {
                    content += `${entry.speaker}\n`;
                }
                content += `${entry.text}\n\n`;
            });
            const fileName = document.getElementById('exportFileName').value.trim() || 'merged_transcript';
            download(content, `${fileName}.txt`, 'text/plain');
        });

        document.getElementById('downloadSrtBtn').addEventListener('click', () => {
            if (!processedData) return;
            const showSpeakers = document.getElementById('toggleSpeakerNames').checked;
            const showCC = document.getElementById('toggleCC').checked;
            const stripSilence = document.getElementById('toggleStripSilence').checked;
            
            // SRT COMPLIANCE FIX: Linearize (No Overlaps)
            // Option A: Keep end times fixed, recalculate starts
            // If Line B overlaps Line A, Line B starts when Line A ends.
            // Ensure minimum display duration so entries don't get compressed to nothing.
            
            // STEP 1: Strip (Silence) and (Blank Audio) entries if enabled - frees up timing space
            const isSilence = (entry) => /^\(\s*(silence|blank\s*audio)\s*\)$/i.test(entry.text.trim());
            const noSilenceData = stripSilence ? processedData.filter(e => !isSilence(e)) : processedData;
            
            // STEP 2: Filter based on visibility toggles
            const showTranscription = document.getElementById('toggleTranscription').checked;
            const isCC = (entry) => entry.speaker === '[CC]' || (entry.text.startsWith('(') && entry.text.endsWith(')'));
            
            const filteredData = noSilenceData.filter(e => {
                if (isCC(e) && !showCC) return false;
                if (!isCC(e) && !showTranscription) return false;
                return true;
            });

            
            const srtData = filteredData.map(entry => ({ ...entry }));
            
            // User-configurable minimum duration (0 = off, only fix overlaps)
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 0;
            
            let lastEnd = 0;
            srtData.forEach((entry, index) => {
                // Force Start to be at least the previous End (fix overlaps)
                if (entry.startSeconds < lastEnd) {
                    entry.startSeconds = lastEnd;
                }
                
                // Apply minimum duration if enabled
                if (minDuration > 0) {
                    const currentDuration = entry.endSeconds - entry.startSeconds;
                    if (currentDuration < minDuration) {
                        entry.endSeconds = entry.startSeconds + minDuration;
                    }
                } else {
                    // Even with minDuration off, ensure valid timing (start < end)
                    if (entry.startSeconds >= entry.endSeconds) {
                        entry.endSeconds = entry.startSeconds + 0.1; // Tiny buffer
                    }
                }
                
                lastEnd = entry.endSeconds;
            });

            let content = '';
            const formatSrtTime = (ms) => {
                const h = Math.floor(ms / 3600000);
                const m = Math.floor((ms % 3600000) / 60000);
                const s = Math.floor((ms % 60000) / 1000);
                const mil = Math.floor(ms % 1000);
                return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')},${String(mil).padStart(3,'0')}`;
            };
            
            let counter = 1;
            srtData.forEach((entry) => {
                // Note: CC entries already filtered above if showCC is false
                const entryIsCC = entry.speaker === '[CC]' || (entry.text.startsWith('(') && entry.text.endsWith(')'));
                
                const startMs = entry.startSeconds * 1000;
                const endMs = entry.endSeconds * 1000;
                content += `${counter++}\n${formatSrtTime(startMs)} --> ${formatSrtTime(endMs)}\n`;
                
                if (showSpeakers && !entryIsCC) { // Don't show speaker name for CC lines in SRT
                     content += `${entry.speaker}: `;
                }
                content += `${entry.text}\n\n`;
            });
            const fileName = document.getElementById('exportFileName').value.trim() || 'merged_transcript';
            download(content, `${fileName}.srt`, 'text/plain');
        });

        document.getElementById('downloadCsvBtn').addEventListener('click', () => {
            if (!processedData) return;
            const showSpeakers = document.getElementById('toggleSpeakerNames').checked;
            const showCC = document.getElementById('toggleCC').checked;
            const stripSilence = document.getElementById('toggleStripSilence').checked;
            
            // STEP 1: Strip (Silence) and (Blank Audio) entries if enabled
            const isSilence = (entry) => /^\(\s*(silence|blank\s*audio)\s*\)$/i.test(entry.text.trim());
            const noSilenceData = stripSilence ? processedData.filter(e => !isSilence(e)) : processedData;
            
            // STEP 2: Filter based on visibility toggles
            const showTranscription = document.getElementById('toggleTranscription').checked;
            const isCC = (entry) => entry.speaker === '[CC]' || (entry.text.startsWith('(') && entry.text.endsWith(')'));
            
            const filteredData = noSilenceData.filter(e => {
                if (isCC(e) && !showCC) return false;
                if (!isCC(e) && !showTranscription) return false;
                return true;
            });

            
            // STEP 3: Clone and apply timing corrections (linearization + min duration)
            const csvData = filteredData.map(entry => ({ ...entry }));
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 0;
            
            let lastEnd = 0;
            csvData.forEach((entry) => {
                // Fix overlaps
                if (entry.startSeconds < lastEnd) {
                    entry.startSeconds = lastEnd;
                }
                // Apply minimum duration
                if (minDuration > 0) {
                    const currentDuration = entry.endSeconds - entry.startSeconds;
                    if (currentDuration < minDuration) {
                        entry.endSeconds = entry.startSeconds + minDuration;
                    }
                } else {
                    if (entry.startSeconds >= entry.endSeconds) {
                        entry.endSeconds = entry.startSeconds + 0.1;
                    }
                }
                lastEnd = entry.endSeconds;
            });
            
            // CSV Helper: Escape values containing commas, quotes, or newlines
            const escapeCSV = (val) => {
                const str = String(val);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return `"${str.replace(/"/g, '""')}"`;
                }
                return str;
            };
            
            // Build CSV content
            let content = showSpeakers 
                ? 'Speaker,Start,End,Text\n' 
                : 'Start,End,Text\n';
            
            csvData.forEach(entry => {
                const start = formatTimecode(entry.startSeconds);
                const end = formatTimecode(entry.endSeconds);
                if (showSpeakers) {
                    content += `${escapeCSV(entry.speaker)},${escapeCSV(start)},${escapeCSV(end)},${escapeCSV(entry.text)}\n`;
                } else {
                    content += `${escapeCSV(start)},${escapeCSV(end)},${escapeCSV(entry.text)}\n`;
                }
            });
            
            const fileName = document.getElementById('exportFileName').value.trim() || 'merged_transcript';
            download(content, `${fileName}.csv`, 'text/csv');
        });

        document.getElementById('downloadJsonBtn').addEventListener('click', () => {
            if (!processedData) return;
            const showSpeakers = document.getElementById('toggleSpeakerNames').checked;
            const showCC = document.getElementById('toggleCC').checked;
            const stripSilence = document.getElementById('toggleStripSilence').checked;
            
            // STEP 1: Strip (Silence) and (Blank Audio) entries if enabled
            const isSilence = (entry) => /^\(\s*(silence|blank\s*audio)\s*\)$/i.test(entry.text.trim());
            const noSilenceData = stripSilence ? processedData.filter(e => !isSilence(e)) : processedData;
            
            // STEP 2: Filter based on visibility toggles
            const showTranscription = document.getElementById('toggleTranscription').checked;
            const isCC = (entry) => entry.speaker === '[CC]' || (entry.text.startsWith('(') && entry.text.endsWith(')'));
            
            const filteredData = noSilenceData.filter(e => {
                if (isCC(e) && !showCC) return false;
                if (!isCC(e) && !showTranscription) return false;
                return true;
            });

            
            // STEP 3: Clone and apply timing corrections (linearization + min duration)
            const jsonData = filteredData.map(entry => ({ ...entry }));
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 0;
            
            let lastEnd = 0;
            jsonData.forEach((entry) => {
                // Fix overlaps
                if (entry.startSeconds < lastEnd) {
                    entry.startSeconds = lastEnd;
                }
                // Apply minimum duration
                if (minDuration > 0) {
                    const currentDuration = entry.endSeconds - entry.startSeconds;
                    if (currentDuration < minDuration) {
                        entry.endSeconds = entry.startSeconds + minDuration;
                    }
                } else {
                    if (entry.startSeconds >= entry.endSeconds) {
                        entry.endSeconds = entry.startSeconds + 0.1;
                    }
                }
                lastEnd = entry.endSeconds;
            });
            
            // Build JSON structure
            const output = jsonData.map((entry, index) => {
                const obj = {
                    index: index + 1,
                    startTime: formatTimecode(entry.startSeconds),
                    endTime: formatTimecode(entry.endSeconds),
                    startSeconds: parseFloat(entry.startSeconds.toFixed(3)),
                    endSeconds: parseFloat(entry.endSeconds.toFixed(3)),
                    text: entry.text
                };
                if (showSpeakers) {
                    obj.speaker = entry.speaker;
                }
                return obj;
            });
            
            const content = JSON.stringify(output, null, 2);
            const fileName = document.getElementById('exportFileName').value.trim() || 'merged_transcript';
            download(content, `${fileName}.json`, 'application/json');
        });

        document.getElementById('copyBtn').addEventListener('click', () => {
            if (!processedData) return;
            const showSpeakers = document.getElementById('toggleSpeakerNames').checked;
            const showCC = document.getElementById('toggleCC').checked;
            const stripSilence = document.getElementById('toggleStripSilence').checked;
            
            // STEP 1: Strip (Silence) and (Blank Audio) entries if enabled
            const isSilence = (entry) => /^\(\s*(silence|blank\s*audio)\s*\)$/i.test(entry.text.trim());
            const noSilenceData = stripSilence ? processedData.filter(e => !isSilence(e)) : processedData;
            
            // STEP 2: Filter based on visibility toggles
            const showTranscription = document.getElementById('toggleTranscription').checked;
            const isCC = (entry) => entry.speaker === '[CC]' || (entry.text.startsWith('(') && entry.text.endsWith(')'));
            
            const filteredData = noSilenceData.filter(e => {
                if (isCC(e) && !showCC) return false;
                if (!isCC(e) && !showTranscription) return false;
                return true;
            });

            
            // STEP 3: Clone and apply timing corrections (linearization + min duration)
            const copyData = filteredData.map(entry => ({ ...entry }));
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 0;
            
            let lastEnd = 0;
            copyData.forEach((entry) => {
                // Fix overlaps
                if (entry.startSeconds < lastEnd) {
                    entry.startSeconds = lastEnd;
                }
                // Apply minimum duration
                if (minDuration > 0) {
                    const currentDuration = entry.endSeconds - entry.startSeconds;
                    if (currentDuration < minDuration) {
                        entry.endSeconds = entry.startSeconds + minDuration;
                    }
                } else {
                    if (entry.startSeconds >= entry.endSeconds) {
                        entry.endSeconds = entry.startSeconds + 0.1;
                    }
                }
                // Update timecode string
                entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
                lastEnd = entry.endSeconds;
            });
            
            let content = '';
            copyData.forEach(entry => {
                content += `${entry.timecode}\n`;
                if (showSpeakers) {
                    content += `${entry.speaker}\n`;
                }
                content += `${entry.text}\n\n`;
            });
            navigator.clipboard.writeText(content).then(() => {
                const originalText = document.getElementById('copyBtn').innerHTML;
                document.getElementById('copyBtn').innerHTML = `<span class="text-green-600 font-bold">Copied!</span>`;
                setTimeout(() => {
                    document.getElementById('copyBtn').innerHTML = originalText;
                }, 2000);
            });
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            // PER-TAB CLEAR: Only clear data for the current mode
            if (currentMode === 'edit') {
                editFile = null;
                filesContainerEdit.innerHTML = '';
                initEditFile();
                // Only clear preview if it was generated by this mode
                if (previewMode === 'edit') {
                    processedData = null;
                    rawProcessedData = null;
                    previewMode = null;
                    document.getElementById('previewSection').classList.add('hidden');
                    document.getElementById('previewList').innerHTML = '';
                    document.getElementById('statEntries').textContent = '0';
                    document.getElementById('statDuration').textContent = '0m';
                    document.getElementById('statSpeakers').textContent = '0';
                }
            } else if (currentMode === 'merge') {
                mergeFiles = [];
                filesContainerMerge.innerHTML = '';
                addMergeFile();
                addMergeFile();
                if (previewMode === 'merge') {
                    processedData = null;
                    rawProcessedData = null;
                    previewMode = null;
                    document.getElementById('previewSection').classList.add('hidden');
                    document.getElementById('previewList').innerHTML = '';
                    document.getElementById('statEntries').textContent = '0';
                    document.getElementById('statDuration').textContent = '0m';
                    document.getElementById('statSpeakers').textContent = '0';
                }
            } else if (currentMode === 'sequence') {
                sequenceFiles = [];
                filesContainerSequence.innerHTML = '';
                addSequenceFile();
                addSequenceFile();
                if (previewMode === 'sequence') {
                    processedData = null;
                    rawProcessedData = null;
                    previewMode = null;
                    document.getElementById('previewSection').classList.add('hidden');
                    document.getElementById('previewList').innerHTML = '';
                    document.getElementById('statEntries').textContent = '0';
                    document.getElementById('statDuration').textContent = '0m';
                    document.getElementById('statSpeakers').textContent = '0';
                }
            }
            
            updateProcessButtonState();
            document.getElementById('clearBtn').blur();
        });

        document.getElementById('addTrackBtn').addEventListener('click', addMergeFile);
        document.getElementById('addPartBtn').addEventListener('click', addSequenceFile);
        processBtn.addEventListener('click', processTranscripts);

        // Toggle Listeners - skipScroll=true to prevent viewport jumping when adjusting settings
        document.getElementById('toggleSpeakerNames').addEventListener('change', () => displayPreview(true));
        document.getElementById('toggleTranscription').addEventListener('change', () => displayPreview(true));
        document.getElementById('toggleCC').addEventListener('change', () => displayPreview(true));

        document.getElementById('toggleStripSilence').addEventListener('change', () => displayPreview(true));
        document.getElementById('toggleLimits').addEventListener('change', () => {
            if (rawProcessedData !== null) reapplyLimits();
        });
        
        // Export filename input - Enter to confirm
        document.getElementById('exportFileName').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                e.target.blur();
            }
        });
        
        // Numeric input listeners - reapply limits on change (preserves edits)
        // Also add Enter key to blur these inputs
        ['settingCpl', 'settingMaxLines', 'settingMinDuration'].forEach(id => {
            const input = document.getElementById(id);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    e.target.blur();
                }
            });
        });
        document.getElementById('settingCpl').addEventListener('input', () => {
            if (rawProcessedData !== null) reapplyLimits();
        });
        document.getElementById('settingMaxLines').addEventListener('input', () => {
            if (rawProcessedData !== null) reapplyLimits();
        });
        document.getElementById('settingMinDuration').addEventListener('input', () => {
            if (processedData !== null) displayPreview(true); // Min duration affects export, not processedData
        });

        // ABOUT MODAL EVENT LISTENERS
        document.getElementById('aboutBtn').addEventListener('click', openAboutModal);
        
        // Close modal when clicking outside
        document.getElementById('aboutModal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('aboutModal')) {
                closeAboutModal();
            }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('aboutModal').classList.contains('active')) {
                closeAboutModal();
            }
        });

        // Init
        initEditFile();
        addMergeFile();
        addMergeFile();
        addSequenceFile();
        addSequenceFile();
    </script>
</body>
</html>