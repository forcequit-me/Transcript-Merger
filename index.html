<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcript Merger</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lucide/latest/umd/lucide.min.js"></script>
    <style>
        [data-icon] {
            display: inline-block;
            width: 1em;
            height: 1em;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
            stroke: currentColor;
        }
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        .drag-active {
            border-color: #6366f1 !important; /* Indigo-500 */
            background-color: #1e293b !important; /* Slate-800 */
        }
        
        /* Dialogue Entry Editing Styles */
        .dialogue-entry {
            position: relative;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .dialogue-entry:hover:not(.selected) {
            border-color: #475569 !important;
        }
        .dialogue-entry.selected {
            border-color: #6366f1 !important;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
        }
        
        /* Edit Action Buttons */
        .edit-actions-top {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        .edit-actions-bottom {
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        .edit-actions-left,
        .edit-actions-center,
        .edit-actions-right {
            display: flex;
            gap: 0.5rem;
            flex: 1;
        }
        .edit-actions-left {
            justify-content: flex-start;
        }
        .edit-actions-center {
            justify-content: center;
        }
        .edit-actions-right {
            justify-content: flex-end;
        }
        .dialogue-entry.selected .edit-actions-top,
        .dialogue-entry.selected .edit-actions-bottom {
            opacity: 1;
            max-height: 50px;
            padding-top: 0.5rem;
        }
        .dialogue-entry.selected .edit-actions-top {
            padding-bottom: 0.5rem;
        }
        
        .edit-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.15s ease;
            border: none;
            cursor: pointer;
        }
        .edit-btn-add {
            background: #334155;
            color: #94a3b8;
        }
        .edit-btn-add:hover {
            background: #475569;
            color: #e2e8f0;
        }
        .edit-btn-save {
            background: #166534;
            color: #86efac;
        }
        .edit-btn-save:hover {
            background: #15803d;
            color: #bbf7d0;
        }
        .edit-btn-delete {
            background: #7f1d1d;
            color: #fca5a5;
        }
        .edit-btn-delete:hover {
            background: #991b1b;
            color: #fecaca;
        }
        .edit-btn-cc {
            background: #1e3a5f;
            color: #7dd3fc;
            font-size: 10px;
            width: auto;
            padding: 0 8px;
        }
        .edit-btn-cc:hover {
            background: #1e40af;
            color: #93c5fd;
        }
        
        /* Speaker Dropdown */
        .speaker-name-container {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        .speaker-name-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.875rem;
            color: #818cf8;
            padding: 4px 0;
            border-radius: 4px;
            transition: all 0.15s ease;
        }
        /* Only show hover/selected background when in edit mode */
        .dialogue-entry.selected .speaker-name-btn {
            background: #334155;
            padding: 4px 10px;
        }
        .dialogue-entry.selected .speaker-name-btn:hover {
            background: #475569;
        }
        /* Fix alignment during edit mode - keep speaker aligned to top */
        .dialogue-entry.selected .entry-content > div:first-child {
            align-items: flex-start;
        }
        .dialogue-entry.selected .speaker-name-container {
            margin-top: 0;
        }
        .speaker-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 180px;
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            z-index: 100;
            overflow: hidden;
            margin-top: 4px;
        }
        .speaker-option {
            padding: 10px 14px;
            cursor: pointer;
            color: #e2e8f0;
            font-size: 0.875rem;
            transition: background 0.1s ease;
        }
        .speaker-option:hover {
            background: #334155;
        }
        .speaker-option.selected {
            background: #4f46e5;
            color: white;
        }
        .speaker-option.custom-option {
            border-top: 1px solid #475569;
            color: #a5b4fc;
        }
        .speaker-option.rename-option {
            border-top: 1px solid #475569;
            color: #fbbf24;
            font-style: italic;
        }
        .speaker-option.rename-option:hover {
            background: #422006;
        }
        .speaker-custom-input {
            width: 100%;
            padding: 10px 14px;
            background: #0f172a;
            border: none;
            border-top: 1px solid #475569;
            color: #e2e8f0;
            font-size: 0.875rem;
            outline: none;
        }
        .speaker-custom-input::placeholder {
            color: #64748b;
        }
        
        /* Editable Text Area */
        .edit-text-input {
            width: 100%;
            min-height: 60px;
            padding: 8px 10px;
            background: #0f172a;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 0.875rem;
            line-height: 1.4;
            resize: vertical;
            outline: none;
            transition: border-color 0.15s ease;
        }
        .edit-text-input:focus {
            border-color: #6366f1;
        }
        
        /* Editable Timing */
        .timing-container {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .edit-timing-input {
            width: 100px;
            padding: 4px 6px;
            background: #0f172a;
            border: 1px solid #475569;
            border-radius: 4px;
            color: #94a3b8;
            font-size: 0.75rem;
            font-family: monospace;
            text-align: center;
            outline: none;
        }
        .edit-timing-input:focus {
            border-color: #6366f1;
            color: #e2e8f0;
        }
        .edit-timing-input.invalid {
            border-color: #ef4444 !important;
            color: #fca5a5;
            background: #450a0a;
        }
        .timing-separator {
            color: #64748b;
            font-size: 0.75rem;
        }
        .timing-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .timing-format-label {
            font-size: 0.6rem;
            color: #64748b;
            font-family: monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Dialogue text display (non-edit mode) */
        .dialogue-text-display {
            color: #cbd5e1;
            font-size: 0.875rem;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        
        /* CC Entry Indicator */
        .cc-indicator {
            display: inline-block;
            background: #1e3a5f;
            color: #7dd3fc;
            padding: 1px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            margin-left: 6px;
        }
        
        /* Custom Checkbox Styling - Cross-browser compatible */
        input[type="checkbox"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            min-width: 16px;
            min-height: 16px;
            border: 2px solid #64748b;
            border-radius: 4px;
            background-color: #1e293b;
            cursor: pointer;
            transition: all 0.15s ease;
            vertical-align: middle;
        }
        input[type="checkbox"]:hover {
            border-color: #818cf8;
        }
        input[type="checkbox"]:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4);
        }
        input[type="checkbox"]:checked {
            background-color: #6366f1;
            border-color: #6366f1;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Cpath fill='none' stroke='white' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round' d='M4 8l3 3 5-6'/%3E%3C/svg%3E");
            background-size: 12px 12px;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        /* Part Separator Styling for Sequencer Mode */
        .part-separator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 1.5rem 0;
            margin: 1rem 0;
        }
        .part-separator::before,
        .part-separator::after {
            content: '';
            flex: 1;
            height: 3px;
            background: linear-gradient(90deg, transparent, #6366f1, transparent);
        }
        .part-separator-label {
            background: linear-gradient(135deg, #4f46e5, #7c3aed);
            color: white;
            font-weight: 700;
            font-size: 0.875rem;
            padding: 0.5rem 1.25rem;
            border-radius: 9999px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4);
        }
        
        /* Framerate Warning Banner */
        .framerate-warning {
            background: linear-gradient(135deg, #422006 0%, #78350f 100%);
            border: 1px solid #f59e0b;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            animation: slideDown 0.3s ease-out;
        }
        .framerate-warning-icon {
            color: #fbbf24;
            flex-shrink: 0;
        }
        .framerate-warning-text {
            color: #fef3c7;
            font-size: 0.875rem;
            flex: 1;
        }
        .framerate-warning-text strong {
            color: #fbbf24;
        }
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Framerate Mismatch Highlight */
        .framerate-mismatch .framerate-select {
            border-color: #ef4444 !important;
            box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3);
        }
    </style>
</head>
<body class="bg-slate-900 p-6 min-h-screen text-slate-200">
    <div class="max-w-4xl mx-auto">
        <!-- Header -->
        <div class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-white mb-2">Transcript Merger</h1>
            <p class="text-slate-400 mb-6">Merge, Edit, or Sequence DaVinci Resolve transcripts</p>
            
            <!-- Tabs -->
            <div class="flex justify-center gap-2">
                <button id="tabMerge" class="px-6 py-2 rounded-full font-semibold bg-indigo-600 text-white shadow-md transition hover:bg-indigo-500">
                    Merge Speakers
                </button>
                <button id="tabEdit" class="px-6 py-2 rounded-full font-semibold bg-slate-800 text-slate-400 hover:bg-slate-700 shadow-sm transition">
                    Edit Transcripts
                </button>
                <button id="tabSequence" class="px-6 py-2 rounded-full font-semibold bg-slate-800 text-slate-400 hover:bg-slate-700 shadow-sm transition">
                    Sequence Transcripts
                </button>
            </div>
            
            <!-- Instructions (positioned below tabs) -->
            <div id="instructionsEdit" class="bg-slate-800/50 border border-slate-700 rounded-lg px-4 py-5 text-left mt-6 hidden">
                <ol class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm text-slate-300">
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-amber-500 flex-shrink-0 leading-none">1</span>
                        <span class="leading-tight">Upload a single transcript file (with or without speaker detection).</span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-amber-500 flex-shrink-0 leading-none">2</span>
                        <span class="leading-tight">Detected speakers are automatically preserved.</span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-amber-500 flex-shrink-0 leading-none">3</span>
                        <span class="leading-tight">Edit entries, then export as TXT or SRT.</span>
                    </li>
                </ol>
            </div>

            <div id="instructionsMerge" class="bg-slate-800/50 border border-slate-700 rounded-lg px-4 py-5 text-left mt-6">
                <ol class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm text-slate-300">
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-indigo-500 flex-shrink-0 leading-none">1</span>
                        <span class="leading-tight">In Resolve put each speaker on a separate audio track (Create Stems)</span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-indigo-500 flex-shrink-0 leading-none">2</span>
                        <span class="leading-tight">Transcribe each stem individually: <strong>with speaker detection DISABLED!</strong></span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-indigo-500 flex-shrink-0 leading-none">3</span>
                        <span class="leading-tight">Export each stem transcript, then upload and merge.</span>
                    </li>
                </ol>
            </div>

            <div id="instructionsSequence" class="bg-slate-800/50 border border-slate-700 rounded-lg px-4 py-5 text-left mt-6 hidden">
                <ol class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm text-slate-300">
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-emerald-500 flex-shrink-0 leading-none">1</span>
                        <span class="leading-tight">Upload transcript parts in order. Use arrows to reorder if needed.</span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-emerald-500 flex-shrink-0 leading-none">2</span>
                        <span class="leading-tight">Enter video clip duration (HH:MM:SS format).</span>
                    </li>
                    <li class="flex items-center gap-3">
                        <span class="text-2xl font-bold text-emerald-500 flex-shrink-0 leading-none">3</span>
                        <span class="leading-tight">Timestamps auto-adjust when sequenced.</span>
                    </li>
                </ol>
            </div>

        </div>

        <!-- Main Card -->
        <div class="bg-slate-800 rounded-lg shadow-lg p-6 mb-6 border border-slate-700">
            
            <!-- EDIT VIEW -->
            <div id="viewEdit" class="hidden">
                <div class="mb-6">
                    <h2 class="text-2xl font-bold text-slate-100 text-center">Edit Transcript</h2>
                </div>
                <div id="filesContainerEdit" class="space-y-3 mb-6"></div>
            </div>

            <!-- MERGE VIEW -->
            <div id="viewMerge">
                <div class="mb-6">
                    <h2 class="text-2xl font-bold text-slate-100 text-center">Upload Speaker Transcriptions</h2>
                </div>
                <div id="filesContainerMerge" class="space-y-3 mb-6"></div>
                <button id="addTrackBtn" class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-slate-700 text-indigo-400 rounded-lg hover:bg-slate-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-indigo-500 mb-6">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                    Add Another Transcription
                </button>
            </div>

            <!-- SEQUENCE VIEW -->
            <div id="viewSequence" class="hidden">
                <div class="mb-6">
                    <h2 class="text-2xl font-bold text-slate-100 text-center">Upload Transcripts and Sequence Them</h2>
                </div>
                <div id="filesContainerSequence" class="space-y-3 mb-6"></div>
                <button id="addPartBtn" class="w-full flex items-center justify-center gap-2 px-4 py-2 bg-slate-700 text-emerald-400 rounded-lg hover:bg-slate-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-emerald-500 mb-6">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                    Add Another Transcript
                </button>
            </div>

            <!-- SUBTITLE LIMITS SETTINGS (Merge mode only) -->
            <div id="subtitleLimitsSection" class="mb-6 bg-slate-900/50 p-4 rounded-lg border border-slate-700">
                <div class="flex flex-col items-center gap-3 mb-4">
                    <h3 class="text-sm font-semibold text-slate-400 uppercase tracking-wider text-center">Subtitle Limits</h3>
                    
                    <!-- Limits Toggle -->
                    <label class="flex items-center gap-2 cursor-pointer bg-slate-800 px-3 py-1 rounded-lg border border-slate-600 hover:bg-slate-700 transition">
                        <input type="checkbox" id="toggleLimits" checked class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 bg-slate-900 border-slate-500">
                        <span class="text-xs text-slate-300 font-medium">Enable Limits</span>
                    </label>
                </div>
                
                <!-- Collapsible Settings Grid -->
                <div id="limitsSettings" class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                    <div>
                        <label class="block text-sm font-medium text-slate-300 mb-1" title="Max characters per line (approximate)">Max Characters Per Line</label>
                        <input type="number" id="settingCpl" value="42" min="1" class="w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-slate-500" />
                        <p class="text-xs text-slate-500 mt-1">Lines may exceed to fit long words.</p>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-300 mb-1" title="Max lines per subtitle card">Max Lines Per Subtitle</label>
                        <input type="number" id="settingMaxLines" value="2" min="1" class="w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-slate-500" />
                        <p class="text-xs text-slate-500 mt-1">Card splits if text exceeds.</p>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-300 mb-1" title="Minimum display time per subtitle (seconds)">Minimum Duration (s)</label>
                        <input type="number" id="settingMinDuration" value="1.5" min="0" step="0.5" class="w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-slate-500" />
                        <p class="text-xs text-slate-500 mt-1">0 = off. Extends short subtitles.</p>
                    </div>
                </div>

                <!-- Visibility Toggles (Centered) -->
                <div class="flex flex-col items-center gap-2 pt-3 border-t border-slate-700">
                    <span class="text-xs text-slate-500 uppercase tracking-wider">Output Options</span>
                    <div class="flex items-center gap-4">
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="toggleSpeakerNames" checked class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 bg-slate-800 border-slate-600">
                            <span class="text-sm text-slate-300">Show Speakers</span>
                        </label>
                        <div class="w-px h-4 bg-slate-700"></div>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="toggleCC" checked class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 bg-slate-800 border-slate-600">
                            <span class="text-sm text-slate-300">Show CC</span>
                        </label>
                        <div class="w-px h-4 bg-slate-700"></div>
                        <label class="flex items-center gap-2 cursor-pointer">
                            <input type="checkbox" id="toggleStripSilence" checked class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500 bg-slate-800 border-slate-600">
                            <span class="text-sm text-slate-300">Strip Silence</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex gap-3">
                <button id="processBtn" class="flex-1 bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-500 transition disabled:bg-slate-600 disabled:text-slate-400 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-slate-800">
                    Merge Transcripts
                </button>
                <button id="clearBtn" class="px-4 py-3 bg-red-900/30 text-red-400 rounded-lg font-semibold border border-red-900/50 shadow-sm transition-all duration-200 ease-in-out hover:bg-red-700 hover:text-white hover:border-red-600 hover:shadow-red-900/50 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 focus:ring-offset-slate-800">
                    Clear All
                </button>
            </div>
        </div>

        <!-- Preview Section -->
        <div id="previewSection" class="bg-slate-800 rounded-lg shadow-lg p-8 hidden border border-slate-700">
            <h2 class="text-2xl font-bold text-slate-100 text-center mb-6">
                Preview
            </h2>
            <!-- Hidden entry count for JS reference -->
            <span id="entryCount" class="hidden">0</span>

            <!-- Export Row -->
            <div class="flex items-center gap-3 mb-6 p-3 bg-slate-900 rounded-lg border border-slate-700">
                <label class="text-sm font-medium text-slate-400 whitespace-nowrap">Rename Export:</label>
                <input type="text" id="exportFileName" value="merged_transcript" class="flex-1 px-3 py-2 bg-slate-800 border border-slate-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-slate-500 text-sm" placeholder="merged_transcript" />
                <button id="copyBtn" class="flex items-center gap-2 px-4 py-2 bg-slate-700 text-slate-300 rounded-lg hover:bg-slate-600 transition font-medium focus:outline-none focus:ring-2 focus:ring-slate-500">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"></path></svg>
                    Copy
                </button>
                <button id="downloadTxtBtn" class="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition font-medium focus:outline-none focus:ring-2 focus:ring-green-500">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                    TXT
                </button>
                <button id="downloadSrtBtn" class="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition font-medium focus:outline-none focus:ring-2 focus:ring-purple-500">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 4v16M17 4v16M3 8h4m10 0h4M3 12h18M3 16h4m10 0h4M4 20h16a1 1 0 001-1V5a1 1 0 00-1-1H4a1 1 0 00-1 1v14a1 1 0 001 1z"></path></svg>
                    SRT
                </button>
            </div>

            <!-- Stats -->
            <div class="grid grid-cols-3 gap-4 mb-6 p-4 bg-slate-900 rounded-lg border border-slate-700">
                <div class="text-center">
                    <p class="text-sm text-slate-400">Total Entries</p>
                    <p class="text-2xl font-bold text-slate-100" id="statEntries">0</p>
                </div>
                <div class="text-center">
                    <p class="text-sm text-slate-400">Duration</p>
                    <p class="text-2xl font-bold text-slate-100" id="statDuration">0m</p>
                </div>
                <div class="text-center">
                    <p class="text-sm text-slate-400">Speakers</p>
                    <p class="text-2xl font-bold text-slate-100" id="statSpeakers">0</p>
                </div>
            </div>

            <!-- Preview List (Increased Height) -->
            <div id="previewList" class="max-h-[800px] overflow-y-auto space-y-4 border border-slate-700 rounded-lg p-4 bg-slate-900"></div>
        </div>
    </div>

    <script>
        // STATE
        let currentMode = 'merge'; // 'edit', 'merge', or 'sequence'
        let editFile = null; // Single file for edit mode
        let mergeFiles = [];
        let sequenceFiles = [];
        let fileIdCounter = 0;
        let processedData = null;
        let previewMode = null; // Track which mode generated the current preview

        // DOM ELEMENTS
        const tabEdit = document.getElementById('tabEdit');
        const tabMerge = document.getElementById('tabMerge');
        const tabSequence = document.getElementById('tabSequence');
        const viewEdit = document.getElementById('viewEdit');
        const viewMerge = document.getElementById('viewMerge');
        const viewSequence = document.getElementById('viewSequence');
        const instructionsEdit = document.getElementById('instructionsEdit');
        const instructionsMerge = document.getElementById('instructionsMerge');
        const instructionsSequence = document.getElementById('instructionsSequence');
        
        const filesContainerEdit = document.getElementById('filesContainerEdit');
        const filesContainerMerge = document.getElementById('filesContainerMerge');
        const filesContainerSequence = document.getElementById('filesContainerSequence');
        
        const processBtn = document.getElementById('processBtn');
        
        // TABS LOGIC
        const inactiveTabClass = "px-6 py-2 rounded-full font-semibold bg-slate-800 text-slate-400 hover:bg-slate-700 shadow-sm transition";
        
        function switchTab(mode) {
            currentMode = mode;
            const subtitleLimitsSection = document.getElementById('subtitleLimitsSection');
            
            // Reset all tabs to inactive
            tabEdit.className = inactiveTabClass;
            tabMerge.className = inactiveTabClass;
            tabSequence.className = inactiveTabClass;
            
            // Hide all views and instructions
            viewEdit.classList.add('hidden');
            viewMerge.classList.add('hidden');
            viewSequence.classList.add('hidden');
            instructionsEdit.classList.add('hidden');
            instructionsMerge.classList.add('hidden');
            instructionsSequence.classList.add('hidden');
            
            // Get export filename input for updating defaults
            const exportFileNameInput = document.getElementById('exportFileName');
            
            if (mode === 'edit') {
                tabEdit.className = "px-6 py-2 rounded-full font-semibold bg-amber-600 text-white shadow-md transition hover:bg-amber-500";
                viewEdit.classList.remove('hidden');
                instructionsEdit.classList.remove('hidden');
                subtitleLimitsSection.classList.remove('hidden');
                processBtn.textContent = "Edit Transcript";
                processBtn.className = processBtn.className
                    .replace(/bg-(indigo|emerald)-600/g, 'bg-amber-600')
                    .replace(/hover:bg-(indigo|emerald)-500/g, 'hover:bg-amber-500');
                // Set default export filename for edit mode
                if (exportFileNameInput && (exportFileNameInput.value === 'merged_transcript' || exportFileNameInput.value === 'sequenced_transcript')) {
                    exportFileNameInput.value = 'edited_transcript';
                    exportFileNameInput.placeholder = 'edited_transcript';
                }
            } else if (mode === 'merge') {
                tabMerge.className = "px-6 py-2 rounded-full font-semibold bg-indigo-600 text-white shadow-md transition hover:bg-indigo-500";
                viewMerge.classList.remove('hidden');
                instructionsMerge.classList.remove('hidden');
                subtitleLimitsSection.classList.remove('hidden');
                processBtn.textContent = "Merge Transcripts";
                processBtn.className = processBtn.className
                    .replace(/bg-(amber|emerald)-600/g, 'bg-indigo-600')
                    .replace(/hover:bg-(amber|emerald)-500/g, 'hover:bg-indigo-500');
                // Set default export filename for merge mode
                if (exportFileNameInput && (exportFileNameInput.value === 'edited_transcript' || exportFileNameInput.value === 'sequenced_transcript')) {
                    exportFileNameInput.value = 'merged_transcript';
                    exportFileNameInput.placeholder = 'merged_transcript';
                }
            } else {
                tabSequence.className = "px-6 py-2 rounded-full font-semibold bg-emerald-600 text-white shadow-md transition hover:bg-emerald-500";
                viewSequence.classList.remove('hidden');
                instructionsSequence.classList.remove('hidden');
                subtitleLimitsSection.classList.remove('hidden');
                processBtn.textContent = "Sequence Transcripts";
                processBtn.className = processBtn.className
                    .replace(/bg-(amber|indigo)-600/g, 'bg-emerald-600')
                    .replace(/hover:bg-(amber|indigo)-500/g, 'hover:bg-emerald-500');
                // Set default export filename for sequence mode
                if (exportFileNameInput && (exportFileNameInput.value === 'merged_transcript' || exportFileNameInput.value === 'edited_transcript')) {
                    exportFileNameInput.value = 'sequenced_transcript';
                    exportFileNameInput.placeholder = 'sequenced_transcript';
                }
            }
            
            // Show/hide preview based on which mode generated it
            if (previewMode !== null && previewMode !== mode) {
                document.getElementById('previewSection').classList.add('hidden');
            } else if (previewMode === mode && processedData !== null) {
                document.getElementById('previewSection').classList.remove('hidden');
            }
            
            updateProcessButtonState();
        }

        tabEdit.addEventListener('click', () => switchTab('edit'));
        tabMerge.addEventListener('click', () => switchTab('merge'));
        tabSequence.addEventListener('click', () => switchTab('sequence'));

        // FILE HANDLING
        function createUploadZone(fileObj, onFileSelect) {
            const zone = document.createElement('label');
            zone.className = "flex items-center justify-center w-full px-4 py-2 border-2 border-dashed border-slate-600 rounded-lg cursor-pointer hover:border-indigo-500 transition focus-within:ring-2 focus-within:ring-indigo-500 focus-within:border-indigo-500 bg-slate-900/50";
            zone.innerHTML = `
                <div class="flex items-center gap-2">
                    <svg class="w-4 h-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                    </svg>
                    <span class="text-sm text-slate-400 file-name">${fileObj.file ? fileObj.file.name : 'Click or Drag file'}</span>
                </div>
                <input type="file" accept=".txt" class="sr-only file-input" />
            `;

            const input = zone.querySelector('input');
            
            // Drag & Drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.add('drag-active'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.remove('drag-active'), false);
            });

            zone.addEventListener('drop', (e) => {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files[0]) handleFile(files[0]);
            });

            input.addEventListener('change', (e) => {
                if (e.target.files[0]) handleFile(e.target.files[0]);
            });

            function handleFile(file) {
                fileObj.file = file;
                zone.querySelector('.file-name').textContent = file.name;
                onFileSelect();
            }

            return zone;
        }

        function initEditFile() {
            // Create single file upload for edit mode
            const fileItem = document.createElement('div');
            fileItem.className = 'bg-slate-900/50 p-3 rounded-lg border border-slate-700';
            fileItem.id = 'file-edit';
            
            fileItem.innerHTML = `
                <div class="flex gap-3 items-start">
                    <div class="flex-1 file-zone-container">
                        <label class="block text-sm font-medium text-slate-300 mb-1">Transcript File</label>
                    </div>
                    <div class="w-28 framerate-container">
                        <label class="block text-sm font-medium text-slate-300 mb-1">Framerate</label>
                        <select class="framerate-select w-full px-2 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-amber-500 text-white text-sm">
                            <option value="ignore" selected>Ignore</option>
                            <option value="23.976">23.976</option>
                            <option value="24">24</option>
                            <option value="25">25</option>
                            <option value="29.97">29.97</option>
                            <option value="30">30</option>
                            <option value="50">50</option>
                            <option value="59.94">59.94</option>
                            <option value="60">60</option>
                            <option value="120">120</option>
                            <option value="custom">+ Custom...</option>
                        </select>
                        <input type="number" class="framerate-custom hidden w-full mt-1 px-2 py-1 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-amber-500 text-white text-sm text-center" placeholder="fps" min="1" max="999.999" step="0.001" />
                    </div>
                </div>
            `;

            const fileObj = { file: null };
            const zone = document.createElement('label');
            zone.className = "flex items-center justify-center w-full px-4 py-3 border-2 border-dashed border-slate-600 rounded-lg cursor-pointer hover:border-amber-500 transition focus-within:ring-2 focus-within:ring-amber-500 focus-within:border-amber-500 bg-slate-900/50";
            zone.innerHTML = `
                <div class="flex items-center gap-2">
                    <svg class="w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
                    </svg>
                    <span class="text-sm text-slate-400 file-name">Click or Drag transcript file</span>
                </div>
                <input type="file" accept=".txt" class="sr-only file-input" />
            `;

            const input = zone.querySelector('input');
            
            // Drag & Drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.add('drag-active'), false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                zone.addEventListener(eventName, () => zone.classList.remove('drag-active'), false);
            });

            zone.addEventListener('drop', (e) => {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files[0]) handleFile(files[0]);
            });

            input.addEventListener('change', (e) => {
                if (e.target.files[0]) handleFile(e.target.files[0]);
            });

            function handleFile(file) {
                editFile = file;
                zone.querySelector('.file-name').textContent = file.name;
                updateProcessButtonState();
            }

            fileItem.querySelector('.file-zone-container').appendChild(zone);
            
            // Framerate select with custom option support
            const framerateSelect = fileItem.querySelector('.framerate-select');
            const framerateCustom = fileItem.querySelector('.framerate-custom');
            framerateSelect.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    framerateCustom.classList.remove('hidden');
                    framerateCustom.focus();
                } else {
                    framerateCustom.classList.add('hidden');
                }
            });
            framerateCustom.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value);
                if (val > 999.999) {
                    e.target.value = "999.999";
                }
            });
            
            filesContainerEdit.appendChild(fileItem);
        }

        function addMergeFile() {
            const id = fileIdCounter++;
            const fileItem = document.createElement('div');
            fileItem.className = 'flex gap-3 items-start bg-slate-900/50 p-3 rounded-lg border border-slate-700';
            fileItem.id = `file-merge-${id}`;
            
            const fileObj = { id, element: fileItem, file: null, label: `Speaker ${mergeFiles.length + 1}`, framerate: 'ignore' };
            mergeFiles.push(fileObj);

            fileItem.innerHTML = `
                <div class="flex-1">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Speaker Label</label>
                    <input type="text" value="${fileObj.label}" class="speaker-label w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white placeholder-slate-500" placeholder="e.g., John" />
                </div>
                <div class="flex-1 file-zone-container">
                    <label class="block text-sm font-medium text-slate-300 mb-1">File</label>
                </div>
                <div class="w-28 framerate-container">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Framerate</label>
                    <select class="framerate-select w-full px-2 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white text-sm">
                        <option value="ignore" selected>Ignore</option>
                        <option value="23.976">23.976</option>
                        <option value="24">24</option>
                        <option value="25">25</option>
                        <option value="29.97">29.97</option>
                        <option value="30">30</option>
                        <option value="50">50</option>
                        <option value="59.94">59.94</option>
                        <option value="60">60</option>
                        <option value="120">120</option>
                        <option value="custom">+ Custom...</option>
                    </select>
                    <input type="number" class="framerate-custom hidden w-full mt-1 px-2 py-1 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-white text-sm text-center" placeholder="fps" min="1" max="999.999" step="0.001" />
                </div>
                <div class="flex flex-col">
                    <span class="block text-sm font-medium text-transparent mb-1 select-none" aria-hidden="true">&nbsp;</span>
                    <button class="remove-btn px-3 py-2 text-red-400 bg-transparent rounded-lg transition-colors duration-200 hover:bg-red-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-red-500">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                </div>
            `;

            const zone = createUploadZone(fileObj, () => {
                if (fileObj.file) {
                    const name = fileObj.file.name.replace(/\.[^/.]+$/, "");
                    fileObj.label = name;
                    fileItem.querySelector('.speaker-label').value = name;
                }
                updateProcessButtonState();
            });
            fileItem.querySelector('.file-zone-container').appendChild(zone);

            fileItem.querySelector('.speaker-label').addEventListener('input', (e) => fileObj.label = e.target.value);
            
            // Framerate select with custom option support
            const framerateSelect = fileItem.querySelector('.framerate-select');
            const framerateCustom = fileItem.querySelector('.framerate-custom');
            framerateSelect.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    framerateCustom.classList.remove('hidden');
                    framerateCustom.focus();
                } else {
                    framerateCustom.classList.add('hidden');
                    fileObj.framerate = e.target.value;
                    updateProcessButtonState();
                }
            });
            framerateCustom.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value);
                if (val > 999.999) {
                    val = 999.999;
                    e.target.value = "999.999";
                }
                if (val > 0) {
                    fileObj.framerate = String(val);
                    updateProcessButtonState();
                }
            });
            fileItem.querySelector('.remove-btn').addEventListener('click', () => {
                mergeFiles = mergeFiles.filter(f => f.id !== id);
                fileItem.remove();
                updateProcessButtonState();
            });

            filesContainerMerge.appendChild(fileItem);
            updateProcessButtonState();
        }

        function addSequenceFile() {
            const id = fileIdCounter++;
            const fileItem = document.createElement('div');
            fileItem.className = 'flex gap-3 items-start bg-slate-900/50 p-3 rounded-lg border border-slate-700';
            fileItem.id = `file-seq-${id}`;
            
            const fileObj = { id, element: fileItem, file: null, duration: "0000:00:00", label: `Part ${sequenceFiles.length + 1}`, framerate: 'ignore' };
            sequenceFiles.push(fileObj);

            fileItem.innerHTML = `
                <div class="flex flex-col items-center gap-1">
                    <button class="move-up text-slate-500 hover:text-slate-300"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path></svg></button>
                    <span class="text-xs font-bold text-slate-500 index-badge">#${sequenceFiles.length}</span>
                    <button class="move-down text-slate-500 hover:text-slate-300"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></button>
                </div>
                <div class="flex-1">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Part Label</label>
                    <input type="text" value="${fileObj.label}" class="part-label w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 text-white placeholder-slate-500" placeholder="e.g., Intro" />
                </div>
                <div class="flex-1 file-zone-container">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Transcript File</label>
                </div>
                <div class="w-36">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Duration</label>
                    <input type="text" value="0000:00:00" class="duration-input w-full px-3 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 text-center font-mono text-white" placeholder="HHHH:MM:SS" />
                </div>
                <div class="w-28 framerate-container">
                    <label class="block text-sm font-medium text-slate-300 mb-1">Framerate</label>
                    <select class="framerate-select w-full px-2 py-2 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 text-white text-sm">
                        <option value="ignore" selected>Ignore</option>
                        <option value="23.976">23.976</option>
                        <option value="24">24</option>
                        <option value="25">25</option>
                        <option value="29.97">29.97</option>
                        <option value="30">30</option>
                        <option value="50">50</option>
                        <option value="59.94">59.94</option>
                        <option value="60">60</option>
                        <option value="120">120</option>
                        <option value="custom">+ Custom...</option>
                    </select>
                    <input type="number" class="framerate-custom hidden w-full mt-1 px-2 py-1 bg-slate-900 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-emerald-500 text-white text-sm text-center" placeholder="fps" min="1" max="999.999" step="0.001" />
                </div>
                <div class="flex flex-col">
                    <span class="block text-sm font-medium text-transparent mb-1 select-none" aria-hidden="true">&nbsp;</span>
                    <button class="remove-btn px-3 py-2 text-red-400 bg-transparent rounded-lg transition-colors duration-200 hover:bg-red-700 hover:text-white focus:outline-none focus:ring-2 focus:ring-red-500">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                </div>
            `;

            const zone = createUploadZone(fileObj, () => {
                // Auto-populate label from filename when file is uploaded
                if (fileObj.file) {
                    const name = fileObj.file.name.replace(/\.[^/.]+$/, "");
                    fileObj.label = name;
                    fileItem.querySelector('.part-label').value = name;
                }
                updateProcessButtonState();
            });
            fileItem.querySelector('.file-zone-container').appendChild(zone);

            // Part label input handler
            fileItem.querySelector('.part-label').addEventListener('input', (e) => fileObj.label = e.target.value);
            
            // Framerate select with custom option support
            const framerateSelect = fileItem.querySelector('.framerate-select');
            const framerateCustom = fileItem.querySelector('.framerate-custom');
            framerateSelect.addEventListener('change', (e) => {
                if (e.target.value === 'custom') {
                    framerateCustom.classList.remove('hidden');
                    framerateCustom.focus();
                } else {
                    framerateCustom.classList.add('hidden');
                    fileObj.framerate = e.target.value;
                    updateProcessButtonState();
                }
            });
            framerateCustom.addEventListener('input', (e) => {
                let val = parseFloat(e.target.value);
                if (val > 999.999) {
                    val = 999.999;
                    e.target.value = "999.999";
                }
                if (val > 0) {
                    fileObj.framerate = String(val);
                    updateProcessButtonState();
                }
            });

            const durationInput = fileItem.querySelector('.duration-input');
            
            // STATE: Track which field is being edited and digit position within field
            let activeFieldIndex = 0;  // 0=hours, 1=minutes, 2=seconds
            let digitPosition = 0;     // Current digit position within the field (0-3 for hours, 0-1 for min/sec)
            let pendingDigits = '';    // Accumulated digits for current field
            
            // Helper to select a specific field
            function selectField(input, fieldIndex) {
                const ranges = [
                    [0, 4],   // Hours (4 digits)
                    [5, 7],   // Minutes
                    [8, 10]   // Seconds
                ];
                const [start, end] = ranges[fieldIndex];
                input.setSelectionRange(start, end);
                activeFieldIndex = fieldIndex;
                digitPosition = 0;  // Reset digit position when field is selected
                pendingDigits = ''; // Clear pending digits
            }
            
            // Get field index from cursor position (for clicks)
            function getFieldFromPosition(pos) {
                if (pos <= 4) return 0; // Hours (0-4)
                if (pos <= 7) return 1; // Minutes (5-7)
                return 2; // Seconds (8-10)
            }
            
            // Parse current value into array [hours, minutes, seconds]
            function parseValue(value) {
                const parts = value.split(':');
                return [
                    (parts[0] || '0000').padStart(4, '0'),
                    (parts[1] || '00').padStart(2, '0'),
                    (parts[2] || '00').padStart(2, '0')
                ];
            }
            
            // Format array back to HHHH:MM:SS
            function formatValue(parts) {
                return `${parts[0].padStart(4, '0')}:${parts[1].padStart(2, '0')}:${parts[2].padStart(2, '0')}`;
            }
            
            // Get the number of digits for a field
            function getFieldDigits(fieldIndex) {
                return fieldIndex === 0 ? 4 : 2; // Hours = 4 digits, Min/Sec = 2 digits
            }
            
            // Get zero value for a field
            function getZeroValue(fieldIndex) {
                return fieldIndex === 0 ? '0000' : '00';
            }
            
            durationInput.addEventListener('keydown', (e) => {
                // Allow tab to move to next input
                if (e.key === 'Tab') {
                    digitPosition = 0;
                    pendingDigits = '';
                    return;
                }
                
                // Allow Ctrl/Cmd shortcuts
                if (e.ctrlKey || e.metaKey) {
                    return;
                }
                
                // Arrow left - move to previous field
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (activeFieldIndex > 0) {
                        selectField(e.target, activeFieldIndex - 1);
                    }
                    return;
                }
                
                // Arrow right - move to next field
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (activeFieldIndex < 2) {
                        selectField(e.target, activeFieldIndex + 1);
                    }
                    return;
                }
                
                // Home - select hours
                if (e.key === 'Home') {
                    e.preventDefault();
                    selectField(e.target, 0);
                    return;
                }
                
                // End - select seconds
                if (e.key === 'End') {
                    e.preventDefault();
                    selectField(e.target, 2);
                    return;
                }
                
                const parts = parseValue(e.target.value);
                
                // Backspace - delete one digit at a time
                if (e.key === 'Backspace' || e.key === 'Delete') {
                    e.preventDefault();
                    
                    const zeroVal = getZeroValue(activeFieldIndex);
                    
                    // If we were in the middle of entering digits, just clear and stay on this field
                    if (digitPosition > 0) {
                        parts[activeFieldIndex] = zeroVal;
                        e.target.value = formatValue(parts);
                        fileObj.duration = e.target.value;
                        digitPosition = 0;
                        pendingDigits = '';
                        selectField(e.target, activeFieldIndex);  // Stay on current field
                        return;
                    }
                    
                    // Check if already zero before attempting deletion
                    const wasAlreadyZero = parts[activeFieldIndex] === zeroVal;
                    
                    if (wasAlreadyZero && activeFieldIndex > 0) {
                        // Already at zero, move to previous field
                        selectField(e.target, activeFieldIndex - 1);
                    } else if (!wasAlreadyZero) {
                        // Shift digits right (remove rightmost, pad left with 0)
                        const currentValue = parts[activeFieldIndex];
                        const shifted = '0' + currentValue.slice(0, -1);
                        parts[activeFieldIndex] = shifted;
                        
                        e.target.value = formatValue(parts);
                        fileObj.duration = e.target.value;
                        
                        // Check if we just made it zero - move to previous field
                        if (parts[activeFieldIndex] === zeroVal && activeFieldIndex > 0) {
                            selectField(e.target, activeFieldIndex - 1);
                        } else {
                            selectField(e.target, activeFieldIndex);
                        }
                    } else {
                        // Already zero but on first field (hours), just stay
                        selectField(e.target, activeFieldIndex);
                    }
                    return;
                }
                
                // Handle digit input
                if (/[0-9]/.test(e.key)) {
                    e.preventDefault();
                    
                    const maxDigits = getFieldDigits(activeFieldIndex);
                    let fieldValue;
                    let shouldAdvance = false;
                    
                    // Add digit to pending
                    pendingDigits += e.key;
                    digitPosition++;
                    
                    if (digitPosition < maxDigits) {
                        // Still building the field value
                        fieldValue = pendingDigits.padStart(maxDigits, '0');
                    } else {
                        // Field is complete
                        fieldValue = pendingDigits.slice(-maxDigits); // Take last N digits
                        const val = parseInt(fieldValue);
                        
                        // Block invalid values for minutes/seconds (must be <= 59)
                        if (activeFieldIndex > 0 && val > 59) {
                            // Invalid input - revert to previous digits minus last
                            pendingDigits = pendingDigits.slice(0, -1);
                            digitPosition--;
                            return;
                        }
                        
                        shouldAdvance = true;
                    }
                    
                    parts[activeFieldIndex] = fieldValue;
                    e.target.value = formatValue(parts);
                    fileObj.duration = e.target.value;
                    
                    // Auto-advance to next field if appropriate
                    if (shouldAdvance && activeFieldIndex < 2) {
                        selectField(e.target, activeFieldIndex + 1);
                    } else if (shouldAdvance) {
                        // On last field after completing digits, re-select it
                        selectField(e.target, activeFieldIndex);
                    } else {
                        // Still entering digits, position cursor BEFORE the next digit slot
                        const ranges = [
                            [0, 4],   // Hours (4 digits)
                            [5, 7],   // Minutes
                            [8, 10]   // Seconds
                        ];
                        const [start, end] = ranges[activeFieldIndex];
                        // Position cursor at the next digit to be entered
                        const cursorPos = start + digitPosition;
                        e.target.setSelectionRange(cursorPos, cursorPos);
                    }
                    return;
                }
                
                // Block all other keys
                e.preventDefault();
            });
            
            // Click to select the field that was clicked
            durationInput.addEventListener('click', (e) => {
                const field = getFieldFromPosition(e.target.selectionStart);
                selectField(e.target, field);
            });
            
            // Focus to select hours by default (for tab navigation)
            durationInput.addEventListener('focus', (e) => {
                selectField(e.target, 0);
            });
            
            // Prevent pasting
            durationInput.addEventListener('paste', (e) => {
                e.preventDefault();
            });
            
            // Auto-reprocess when duration changes (if preview already exists)
            durationInput.addEventListener('change', () => {
                if (previewMode === 'sequence' && processedData !== null) {
                    processTranscripts();
                }
            });
            
            // Reordering Logic
            fileItem.querySelector('.move-up').addEventListener('click', () => moveFile(id, -1));
            fileItem.querySelector('.move-down').addEventListener('click', () => moveFile(id, 1));

            fileItem.querySelector('.remove-btn').addEventListener('click', () => {
                sequenceFiles = sequenceFiles.filter(f => f.id !== id);
                fileItem.remove();
                updateSequenceIndices();
                updateProcessButtonState();
            });

            filesContainerSequence.appendChild(fileItem);
            updateSequenceIndices();
            updateProcessButtonState();
        }

        function moveFile(id, direction) {
            const index = sequenceFiles.findIndex(f => f.id === id);
            if (index < 0) return;
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= sequenceFiles.length) return;

            // Swap in array
            [sequenceFiles[index], sequenceFiles[newIndex]] = [sequenceFiles[newIndex], sequenceFiles[index]];
            
            // Swap in DOM
            const container = filesContainerSequence;
            const items = Array.from(container.children);
            if (direction === -1) {
                container.insertBefore(items[index], items[newIndex]);
            } else {
                container.insertBefore(items[newIndex], items[index]);
            }
            
            updateSequenceIndices();
            
            // Auto-reprocess when order changes (if preview already exists)
            if (previewMode === 'sequence' && processedData !== null) {
                processTranscripts();
            }
        }

        function updateSequenceIndices() {
            sequenceFiles.forEach((f, idx) => {
                f.element.querySelector('.index-badge').textContent = `#${idx + 1}`;
            });
        }

        function updateProcessButtonState() {
            let hasFiles = false;
            let framerateMismatch = false;
            
            // Determine if we have files
            if (currentMode === 'edit') {
                hasFiles = editFile !== null;
            } else if (currentMode === 'merge') {
                hasFiles = mergeFiles.length > 0 && mergeFiles.every(f => f.file);
                
                // Check framerate consistency
                if (hasFiles && mergeFiles.length > 1) {
                    const framerates = mergeFiles.map(f => f.framerate || 'ignore');
                    const uniqueFramerates = [...new Set(framerates)];
                    framerateMismatch = uniqueFramerates.length > 1;
                    
                    // Update UI for mismatch highlighting
                    updateFramerateMismatchUI(mergeFiles, framerateMismatch, filesContainerMerge);
                }
            } else {
                hasFiles = sequenceFiles.length > 0 && sequenceFiles.every(f => f.file);
                
                // Check framerate consistency
                if (hasFiles && sequenceFiles.length > 1) {
                    const framerates = sequenceFiles.map(f => f.framerate || 'ignore');
                    const uniqueFramerates = [...new Set(framerates)];
                    framerateMismatch = uniqueFramerates.length > 1;
                    
                    // Update UI for mismatch highlighting
                    updateFramerateMismatchUI(sequenceFiles, framerateMismatch, filesContainerSequence);
                }
            }
            
            // Update button state and text
            processBtn.disabled = !hasFiles || framerateMismatch;
            if (framerateMismatch) {
                processBtn.textContent = ' Framerates Mismatch';
                processBtn.title = 'All files must have the same framerate setting';
            } else {
                processBtn.textContent = 'Process Transcripts';
                processBtn.title = '';
            }
        }
        
        function updateFramerateMismatchUI(files, hasMismatch, container) {
            // Remove existing warning
            const existingWarning = container.querySelector('.framerate-warning');
            if (existingWarning) existingWarning.remove();
            
            // Find the most common framerate to highlight mismatches
            const framerateCounts = {};
            files.forEach(f => {
                const fr = f.framerate || 'ignore';
                framerateCounts[fr] = (framerateCounts[fr] || 0) + 1;
            });
            const mostCommon = Object.entries(framerateCounts).sort((a, b) => b[1] - a[1])[0]?.[0];
            
            // Update each file's UI
            files.forEach(f => {
                const frContainer = f.element.querySelector('.framerate-container');
                if (frContainer) {
                    const fr = f.framerate || 'ignore';
                    if (hasMismatch && fr !== mostCommon) {
                        frContainer.classList.add('framerate-mismatch');
                    } else {
                        frContainer.classList.remove('framerate-mismatch');
                    }
                }
            });
            
            // Add warning banner if mismatch
            if (hasMismatch) {
                const warning = document.createElement('div');
                warning.className = 'framerate-warning';
                warning.innerHTML = `
                    <svg class="framerate-warning-icon w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                    </svg>
                    <span class="framerate-warning-text">
                        <strong>Framerate mismatch:</strong> All files must use the same framerate. Adjust the highlighted dropdowns.
                    </span>
                `;
                container.insertBefore(warning, container.firstChild);
            }
        }

        // PARSING & PROCESSING
        function parseTimecode(timecodeStr) {
            const match = timecodeStr.match(/\[(\d+):(\d+):(\d+):(\d+)\s*-/);
            if (match) {
                const [, h, m, s, ff] = match.map(Number);
                return h * 3600 + m * 60 + s + ff / 30;
            }
            return 0;
        }

        function parseDuration(durationStr) {
            const parts = durationStr.split(':').map(Number);
            if (parts.length === 3) {
                return parts[0] * 3600 + parts[1] * 60 + parts[2];
            }
            return 0;
        }

        function formatTimecode(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const ff = Math.floor((seconds % 1) * 30);
            return `${String(h).padStart(4,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}:${String(ff).padStart(2,'0')}`;
        }

        async function parseTranscript(content, speakerLabel, timeOffset = 0) {
            const entries = [];
            const blocks = content.split(/\n(?=\[)/);

            blocks.forEach(block => {
                const lines = block.trim().split('\n');
                if (!lines[0].startsWith('[')) return;

                const timecodeMatch = lines[0].match(/\[(\d+):(\d+):(\d+):(\d+)\s*-\s*(\d+):(\d+):(\d+):(\d+)\]/);
                if (!timecodeMatch) return;

                // Parse Start
                let startSec = parseInt(timecodeMatch[1])*3600 + parseInt(timecodeMatch[2])*60 + parseInt(timecodeMatch[3]) + parseInt(timecodeMatch[4])/30;
                // Parse End
                let endSec = parseInt(timecodeMatch[5])*3600 + parseInt(timecodeMatch[6])*60 + parseInt(timecodeMatch[7]) + parseInt(timecodeMatch[8])/30;

                // Apply Offset
                startSec += timeOffset;
                endSec += timeOffset;

                const newTimecode = `[${formatTimecode(startSec)} - ${formatTimecode(endSec)}]`;

                let textStart = 1;
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].startsWith('Speaker')) {
                        textStart = i + 1;
                        break;
                    }
                }

                const text = lines.slice(textStart).join('\n').trim();
                if (text) {
                    entries.push({
                        startSeconds: startSec,
                        endSeconds: endSec,
                        timecode: newTimecode,
                        speaker: speakerLabel,
                        text
                    });
                }
            });
            return entries;
        }

        async function processTranscripts() {
            try {
                let allEntries = [];

                if (currentMode === 'edit') {
                    // Edit mode: single file with auto speaker detection
                    const content = await editFile.text();
                    const entries = await parseTranscript(content, null, 0); // null = use detected speakers
                    
                    // Normalize base timecode offset (DaVinci Resolve often starts at 01:00:00:00)
                    if (entries.length > 0) {
                        const baseOffset = entries[0].startSeconds;
                        entries.forEach(entry => {
                            entry.startSeconds = entry.startSeconds - baseOffset;
                            entry.endSeconds = entry.endSeconds - baseOffset;
                            entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
                        });
                    }
                    
                    allEntries = entries;
                    allEntries.sort((a, b) => a.startSeconds - b.startSeconds);
                } else if (currentMode === 'merge') {
                    // Collect all entries first, then normalize based on the earliest timestamp
                    let rawEntries = [];
                    for (const fileObj of mergeFiles) {
                        const content = await fileObj.file.text();
                        const entries = await parseTranscript(content, fileObj.label, 0);
                        rawEntries = rawEntries.concat(entries);
                    }
                    rawEntries.sort((a, b) => a.startSeconds - b.startSeconds);
                    
                    // Normalize base timecode offset (DaVinci Resolve often starts at 01:00:00:00)
                    if (rawEntries.length > 0) {
                        const baseOffset = rawEntries[0].startSeconds;
                        rawEntries.forEach(entry => {
                            entry.startSeconds = entry.startSeconds - baseOffset;
                            entry.endSeconds = entry.endSeconds - baseOffset;
                            entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
                        });
                    }
                    
                    allEntries = rawEntries;
                } else {
                    let currentOffset = 0;
                    let partIndex = 1;
                    for (const fileObj of sequenceFiles) {
                        const content = await fileObj.file.text();
                        
                        // Parse entries WITHOUT offset first to detect base timecode
                        const rawEntries = await parseTranscript(content, null, 0);
                        
                        if (rawEntries.length > 0) {
                            // Detect the base timecode offset from the first entry
                            // DaVinci Resolve often uses record timecode starting at 01:00:00:00
                            // We need to normalize this to relative time (starting at 0)
                            const baseOffset = rawEntries[0].startSeconds;
                            
                            // Apply normalization: subtract base offset, then add cumulative sequence offset
                            rawEntries.forEach(entry => {
                                entry.startSeconds = entry.startSeconds - baseOffset + currentOffset;
                                entry.endSeconds = entry.endSeconds - baseOffset + currentOffset;
                                entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
                                entry.partNumber = partIndex;
                                entry.partLabel = fileObj.label; // Store the custom part label
                            });
                            
                            allEntries = allEntries.concat(rawEntries);
                        }
                        
                        currentOffset += parseDuration(fileObj.duration);
                        partIndex++;
                    }
                }

                // 1. FLATTEN TIME SLICES (Merge overlapping CC/Dialogue)
                // Creates a linear, non-overlapping stream with composite Text
                let flattenedEntries = flattenTracks(allEntries);

                // 2. APPLY SUBTITLE LIMITS (All modes when enabled)
                const cpl = parseInt(document.getElementById('settingCpl').value) || 11;
                const maxLines = parseInt(document.getElementById('settingMaxLines').value) || 2;
                const enableLimits = document.getElementById('toggleLimits').checked;
                
                // Apply limits in all modes when enabled
                if (enableLimits) {
                    processedData = applyLimits(flattenedEntries, cpl, maxLines);
                } else {
                    processedData = flattenedEntries;
                }
                
                previewMode = currentMode; // Store which mode generated this preview
                displayPreview();
            } catch (error) {
                alert('Error processing files: ' + error.message);
                console.error(error);
            }
        }
        
        function flattenTracks(entries) {
            if (entries.length === 0) return [];
            
            // HELPER: Normalize text for comparison (lowercase, no punctuation)
            const normalizeText = (str) => str.toLowerCase().replace(/[^\w\s]/g, '').replace(/\s+/g, ' ').trim();
            
            // HELPER: Smart merge text - avoids duplicates and subsets
            const smartMergeText = (currentText, nextText) => {
                const currentNorm = normalizeText(currentText);
                const nextNorm = normalizeText(nextText);
                
                // If texts are identical (normalized), keep current
                if (currentNorm === nextNorm) {
                    return currentText;
                }
                
                // If next is a subset of current, keep current
                if (currentNorm.includes(nextNorm)) {
                    return currentText;
                }
                
                // If current is a subset of next, prefer next (it's more complete)
                if (nextNorm.includes(currentNorm)) {
                    return nextText;
                }
                
                // Genuinely different content - combine them
                return currentText + " " + nextText;
            };
            
            // 0. SEPARATE TRACKS
            const ccEntries = [];
            const diagEntries = [];
            
            entries.forEach(e => {
                if (e.speaker === '[CC]') {
                    ccEntries.push(e);
                } else {
                    diagEntries.push(e);
                }
            });
            
            // 1. CLEAN & MERGE CC TRACKS (Aggressive Merge for identical SFX)
            // Goal: Overlapping "(Phone Beeps)" from multiple files should become ONE entry.
            function mergeCC(cclist) {
                if (cclist.length === 0) return [];
                // Sort by Start Time for merging logic
                cclist.sort((a, b) => a.startSeconds - b.startSeconds);
                
                const merged = [];
                let current = { ...cclist[0] };
                
                for (let i = 1; i < cclist.length; i++) {
                    const next = cclist[i];
                    
                    // Overlap?
                    if (next.startSeconds < current.endSeconds + 0.1) {
                        // If same text, merge them into one long block
                        if (current.text === next.text) {
                            current.endSeconds = Math.max(current.endSeconds, next.endSeconds);
                            // Keep earliest start
                        } else {
                            // Different CC text overlapping?
                            // Just flow them naturally. 
                            // If Next starts before Current ends, we can't easily merge different texts in CC without clutter.
                            // But usually CC is sparse. Let's push current and start new.
                            merged.push(current);
                            current = { ...next };
                        }
                    } else {
                        merged.push(current);
                        current = { ...next };
                    }
                }
                merged.push(current);
                return merged;
            }
            
            const cleanCC = mergeCC(ccEntries);
            
            // 2. CLEAN & MERGE DIALOGUE TRACKS (Heal fragmented lines)
            // Goal: If "Samantha" is split into two parts by "Theodore" in the input file (old logic artifact),
            // or if the user uploads a file with split lines, we want to re-join them into one "block" 
            // so they sort correctly by End Time.
            function mergeDialogue(dlist) {
                if (dlist.length === 0) return [];
                // Sort by Start Time to find adjacent fragments
                dlist.sort((a, b) => a.startSeconds - b.startSeconds);
                
                const merged = [];
                let current = { ...dlist[0] };
                
                for (let i = 1; i < dlist.length; i++) {
                    const next = dlist[i];
                    
                    // Check strict adjacency (Gap < 0.5s) AND Same Speaker
                    // We assume inputs are "Tracks", so same speaker name = same person.
                    const gap = next.startSeconds - current.endSeconds;
                    const isSameSpeaker = current.speaker === next.speaker;
                    
                    // Allow small overlap or small gap
                    const isAdjacent = gap < 0.5; // 0.5s tolerance for "sentence pause"
                    
                    if (isSameSpeaker && (isAdjacent || next.startSeconds < current.endSeconds)) {
                        // MERGE
                        current.endSeconds = Math.max(current.endSeconds, next.endSeconds);
                        current.startSeconds = Math.min(current.startSeconds, next.startSeconds); // Should be current.start, but safety
                        
                        // Merge Text (Smart deduplication)
                        current.text = smartMergeText(current.text, next.text);
                    } else {
                         merged.push(current);
                         current = { ...next };
                    }
                }
                merged.push(current);
                return merged;
            }

            const cleanDialogue = mergeDialogue(diagEntries);
            
            // 3. COMBINE & SORT BY END TIME (User Request: "Who stops talking last")
            // This ensures short interjections (ending early) appear before the long speech (ending late) finishes.
            
            let allClean = [...cleanCC, ...cleanDialogue];
            
            // SORT LOGIC: End Time ASC, then Start Time ASC
            allClean.sort((a, b) => {
                if (Math.abs(a.endSeconds - b.endSeconds) > 0.05) {
                    return a.endSeconds - b.endSeconds;
                }
                return a.startSeconds - b.startSeconds;
            });
            
            // 4. FINAL PASS: MERGE ADJACENT SAME-SPEAKER
            // If the sorted list has two adjacent entries from SAME speaker, merge them.
            // This handles the case where we just sorted them together.
            
            const finalMerged = [];
            if (allClean.length > 0) {
                let current = allClean[0];
                
                for (let i = 1; i < allClean.length; i++) {
                    const next = allClean[i];
                    
                    const isSameSpeaker = current.speaker === next.speaker;
                    // Check adjacency (current end ~ next start) OR Overlap
                    // Since we sorted by End Time, 'next' could actually start BEFORE 'current'.
                    // Merge if:
                    // 1. Same Speaker
                    // 2. Gap is small (< 0.5s) OR Overlapping
                    const gap = next.startSeconds - current.endSeconds;
                    const isClose = gap < 0.5; // Allow small silence to bridge
                    // Also check if 'next' is completely contained or overlapping significantly?
                    // If we merge, we extend End Time.
                    
                    if (isSameSpeaker && (isClose || next.startSeconds < current.endSeconds)) {
                        // MERGE
                        // Update End
                        current.endSeconds = Math.max(current.endSeconds, next.endSeconds);
                        // Update Start (if next started earlier, which is possible with End-Sort)
                        current.startSeconds = Math.min(current.startSeconds, next.startSeconds);
                        
                        // Merge Text (Smart deduplication)
                        current.text = smartMergeText(current.text, next.text);
                        
                        // Update Timecode
                        current.timecode = `[${formatTimecode(current.startSeconds)} - ${formatTimecode(current.endSeconds)}]`;
                        
                    } else {
                        finalMerged.push(current);
                        current = next;
                    }
                }
                finalMerged.push(current);
            }
            
            return finalMerged;
        }
        
        // LIMIT LOGIC
        function applyLimits(entries, cplLimit, maxLinesLimit) {
            let newEntries = [];
            
            entries.forEach(entry => {
                // 1. PURE CC: Pass through (Exempt)
                if (entry.speaker === '[CC]') {
                    newEntries.push(entry);
                    return;
                }

                // 2. COMPOSITE CARD (CC Header + Dialogue Body)
                // Identified by empty speaker (baked into text)
                if (entry.speaker === '') {
                    const lines = entry.text.split('\n');
                    if (lines.length > 1) {
                         // Detach CC Header
                         const header = lines[0];
                         const body = lines.slice(1).join('\n');
                         
                         // Process Body (Dialogue) against limits
                         // We create a temp entry for the splitter
                         const tempEntry = { ...entry, text: body };
                         const splitEntries = createLimitEntries(tempEntry, cplLimit, maxLinesLimit);
                         
                         // Re-attach Header to the FIRST card only
                         if (splitEntries.length > 0) {
                             splitEntries[0].text = header + '\n' + splitEntries[0].text;
                         }
                         
                         newEntries = newEntries.concat(splitEntries);
                         return;
                    }
                    // Fallback if split failed or single line? Treat as normal.
                }

                // 3. STANDARD DIALOGUE
                const splitEntries = createLimitEntries(entry, cplLimit, maxLinesLimit);
                newEntries = newEntries.concat(splitEntries);
            });
            
            return newEntries;
        }
        
        function createLimitEntries(originalEntry, cpl, maxLines) {
            // 1. Wrap logic (Greedy Overflow)
            const words = originalEntry.text.split(/\s+/);
            const lines = [];
            let currentLine = [];
            let currentLen = 0;
            
            words.forEach(word => {
                const wordLen = word.length;
                // Add 1 for space if line not empty
                const spaceLen = currentLine.length > 0 ? 1 : 0;
                
                // Add word to current line tentatively
                currentLine.push(word);
                currentLen += spaceLen + wordLen;
                
                // Check if we exceeded the limit
                if (currentLen > cpl) {
                    // Line is full. Commit.
                    lines.push(currentLine.join(' '));
                    currentLine = [];
                    currentLen = 0;
                }
            });
            
            // Push remaining
            if (currentLine.length > 0) {
                lines.push(currentLine.join(' '));
            }
            
            // 2. Pagination logic
            const pages = [];
            for (let i = 0; i < lines.length; i += maxLines) {
                pages.push(lines.slice(i, i + maxLines).join('\n'));
            }
            
            if (pages.length === 1) {
                return [{
                    ...originalEntry,
                    text: pages[0]
                }];
            }
            
            // 3. Timestamp Interpolation
            const totalDuration = originalEntry.endSeconds - originalEntry.startSeconds;
            const totalChars = pages.reduce((acc, page) => acc + page.length, 0); 
            
            let currentStart = originalEntry.startSeconds;
            const resultEntries = [];
            
            pages.forEach((pageText, idx) => {
                const charCount = pageText.length;
                const fraction = totalChars > 0 ? (charCount / totalChars) : (1 / pages.length);
                let duration = totalDuration * fraction;
                
                let pageEnd = currentStart + duration;
                
                if (idx === pages.length - 1) {
                    pageEnd = originalEntry.endSeconds;
                }
                
                resultEntries.push({
                    startSeconds: currentStart,
                    endSeconds: pageEnd,
                    timecode: `[${formatTimecode(currentStart)} - ${formatTimecode(pageEnd)}]`,
                    speaker: originalEntry.speaker,
                    text: pageText,
                    partNumber: originalEntry.partNumber // Preserve part number for sequencer mode
                });
                
                currentStart = pageEnd;
            });
            
            return resultEntries;
        }

        // OVERRIDE PARSER FOR SPEAKER EXTRACTION & CC SEPARATION
        async function parseTranscript(content, speakerLabelOverride, timeOffset = 0) {
            const entries = [];
            const blocks = content.split(/\n(?=\[)/);

            // 1. Detect forced CC mode
            let isForcedCC = false;
            if (speakerLabelOverride) {
                const norm = speakerLabelOverride.trim().toLowerCase();
                if (['cc', 'sfx', 'sound', 'sound effects'].includes(norm)) {
                    isForcedCC = true;
                    speakerLabelOverride = '[CC]';
                }
            }

            blocks.forEach(block => {
                const lines = block.trim().split('\n');
                if (!lines[0].startsWith('[')) return;

                const timecodeMatch = lines[0].match(/\[(\d+):(\d+):(\d+):(\d+)\s*-\s*(\d+):(\d+):(\d+):(\d+)\]/);
                if (!timecodeMatch) return;

                let startSec = parseInt(timecodeMatch[1])*3600 + parseInt(timecodeMatch[2])*60 + parseInt(timecodeMatch[3]) + parseInt(timecodeMatch[4])/30;
                let endSec = parseInt(timecodeMatch[5])*3600 + parseInt(timecodeMatch[6])*60 + parseInt(timecodeMatch[7]) + parseInt(timecodeMatch[8])/30;

                startSec += timeOffset;
                endSec += timeOffset;

                const newTimecode = `[${formatTimecode(startSec)} - ${formatTimecode(endSec)}]`;

                let textStart = 1;
                let extractedSpeaker = "Unknown";
                
                // Try to find line starting with "Speaker"
                let foundSpeakerPrefix = false;
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].startsWith('Speaker')) {
                        extractedSpeaker = lines[i].replace('Speaker', '').replace(':', '').trim() || "Speaker";
                        if (extractedSpeaker === "Speaker") extractedSpeaker = lines[i].trim(); 
                        textStart = i + 1;
                        foundSpeakerPrefix = true;
                        break;
                    }
                }

                if (!foundSpeakerPrefix && !speakerLabelOverride && lines.length > 1) {
                    const potentialSpeaker = lines[1].trim();
                    if (potentialSpeaker.length > 0 && potentialSpeaker.length < 50) {
                        extractedSpeaker = potentialSpeaker;
                        textStart = 2;
                    }
                }

                // Process Text Lines
                let rawLines = lines.slice(textStart).map(l => l.trim()).filter(l => l);
                
                // If Forced CC, all lines are CC
                if (isForcedCC) {
                    if (rawLines.length > 0) {
                        entries.push({
                            startSeconds: startSec,
                            endSeconds: endSec,
                            timecode: newTimecode,
                            speaker: '[CC]',
                            text: rawLines.join('\n')
                        });
                    }
                    return;
                }

                // Normal Mode: Split Mixed Lines
                const finalSpeaker = speakerLabelOverride || extractedSpeaker;
                
                rawLines.forEach(line => {
                    // Regex for (text) or [text]
                    // We need to support "Mixed" lines: "(Beep) Hello world" or "Hello (Laughs)"
                    // But also simple "(Beep)"
                    
                    // Strategy: Split by parens capturing delimiter
                    const parts = line.split(/(\([^\)]+\)|\[[^\]]+\])/g).filter(p => p.trim());
                    
                    parts.forEach(part => {
                        const trimmed = part.trim();
                        const isCC = (trimmed.startsWith('(') && trimmed.endsWith(')')) || 
                                     (trimmed.startsWith('[') && trimmed.endsWith(']'));
                                     
                        if (isCC) {
                            entries.push({
                                startSeconds: startSec,
                                endSeconds: endSec,
                                timecode: newTimecode,
                                speaker: '[CC]',
                                text: trimmed
                            });
                        } else {
                            entries.push({
                                startSeconds: startSec,
                                endSeconds: endSec,
                                timecode: newTimecode,
                                speaker: finalSpeaker,
                                text: trimmed
                            });
                        }
                    });
                });
            });
            return entries;
        }

        // EDITING STATE
        let selectedEntryIndex = null;
        let openDropdownIndex = null;

        function displayPreview(skipScroll = false) {
            // Filter based on toggles
            const showSpeakers = document.getElementById('toggleSpeakerNames').checked;
            const showCC = document.getElementById('toggleCC').checked;
            const stripSilence = document.getElementById('toggleStripSilence').checked;
            
            // Helper to check if entry is a silence marker
            const isSilence = (entry) => /^\(\s*silence\s*\)$/i.test(entry.text.trim());
            
            document.getElementById('entryCount').textContent = processedData.length;
            document.getElementById('statEntries').textContent = processedData.length;
            
            // Calculate duration based on mode
            let durationMinutes = 0;
            if (previewMode === 'sequence') {
                // For sequence mode, sum the user-entered durations from the input fields
                let totalSeconds = 0;
                sequenceFiles.forEach(f => {
                    totalSeconds += parseDuration(f.duration);
                });
                durationMinutes = Math.floor(totalSeconds / 60);
            } else {
                // For merge/edit mode, use the last entry's end time
                const lastEntry = processedData[processedData.length - 1];
                durationMinutes = lastEntry ? Math.floor(lastEntry.endSeconds / 60) : 0;
            }
            document.getElementById('statDuration').textContent = durationMinutes + 'm';
            
            // Count unique speakers, excluding [CC]
            const speakerSet = new Set(processedData.filter(e => e.speaker !== '[CC]').map(e => e.speaker));
            document.getElementById('statSpeakers').textContent = speakerSet.size;

            const previewList = document.getElementById('previewList');
            previewList.innerHTML = '';

            // Track last part number for separator insertion in sequence mode
            let lastPartNumber = 0;

            processedData.forEach((entry, index) => {
                const isCC = entry.speaker === '[CC]' || entry.text.startsWith('(') && entry.text.endsWith(')');
                
                // VISIBILITY CHECK
                if (isCC && !showCC) return; // Skip if CC hidden
                if (stripSilence && isSilence(entry)) return; // Skip silence entries if Strip Silence enabled
                
                // ADD PART SEPARATOR for Sequencer mode when entering a new part
                if (previewMode === 'sequence' && entry.partNumber && entry.partNumber !== lastPartNumber) {
                    // Use custom label if available, otherwise fall back to generic "Part N"
                    const labelText = entry.partLabel || `Part ${entry.partNumber}`;
                    
                    // Only show separator if not the first part (visual separator between parts)
                    if (lastPartNumber > 0 || index > 0) {
                        const separator = document.createElement('div');
                        separator.className = 'part-separator';
                        separator.innerHTML = `<span class="part-separator-label">${escapeHtml(labelText)}</span>`;
                        previewList.appendChild(separator);
                    } else if (entry.partNumber === 1) {
                        // For the very first entry, just show a subtle part label
                        const separator = document.createElement('div');
                        separator.className = 'part-separator';
                        separator.style.paddingTop = '0.5rem';
                        separator.innerHTML = `<span class="part-separator-label">${escapeHtml(labelText)}</span>`;
                        previewList.appendChild(separator);
                    }
                    lastPartNumber = entry.partNumber;
                }
                
                const div = document.createElement('div');
                div.className = 'dialogue-entry bg-slate-800 p-3 rounded border border-slate-700';
                div.dataset.index = index;
                
                // Toggle Speaker Visibility
                const speakerStyle = showSpeakers ? '' : 'display: none;';
                
                div.innerHTML = `
                    <!-- Top Action Buttons -->
                    <div class="edit-actions-top">
                        <button class="edit-btn edit-btn-add btn-add-above" title="Add dialogue above">+</button>
                        <button class="edit-btn edit-btn-cc btn-cc-above" title="Add CC above">CC</button>
                    </div>
                    
                    <!-- Entry Content -->
                    <div class="entry-content">
                        <div class="flex items-center justify-between mb-2">
                            <div class="speaker-name-container" style="${speakerStyle}">
                                <button class="speaker-name-btn">${entry.speaker}</button>
                                ${isCC ? '<span class="cc-indicator">CC</span>' : ''}
                            </div>
                            <div class="timing-container timing-display">
                                <span class="text-xs text-slate-500">${entry.timecode}</span>
                            </div>
                        </div>
                        <div class="dialogue-text-container">
                            <p class="dialogue-text-display">${escapeHtml(entry.text)}</p>
                        </div>
                    </div>
                    
                    <!-- Bottom Action Buttons -->
                    <div class="edit-actions-bottom">
                        <div class="edit-actions-left"></div>
                        <div class="edit-actions-center">
                            <button class="edit-btn edit-btn-add btn-add-below" title="Add dialogue below">+</button>
                            <button class="edit-btn edit-btn-cc btn-cc-below" title="Add CC below">CC</button>
                        </div>
                        <div class="edit-actions-right">
                            <button class="edit-btn edit-btn-save btn-save" title="Save changes"></button>
                            <button class="edit-btn edit-btn-delete btn-delete" title="Delete entry"></button>
                        </div>
                    </div>
                `;
                
                // Click handler for selection
                div.addEventListener('click', (e) => {
                    // Don't select if clicking on buttons or inputs
                    if (e.target.closest('.edit-btn') || e.target.closest('.speaker-dropdown') || 
                        e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                        return;
                    }
                    selectEntry(index);
                });
                
                // Speaker dropdown handler
                const speakerBtn = div.querySelector('.speaker-name-btn');
                speakerBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (selectedEntryIndex === index) {
                        toggleSpeakerDropdown(index, speakerBtn);
                    }
                });
                
                // Add Above button
                div.querySelector('.btn-add-above').addEventListener('click', (e) => {
                    e.stopPropagation();
                    addEntryAbove(index, false);
                });
                
                // Add CC Above button
                div.querySelector('.btn-cc-above').addEventListener('click', (e) => {
                    e.stopPropagation();
                    addEntryAbove(index, true);
                });
                
                // Add Below button
                div.querySelector('.btn-add-below').addEventListener('click', (e) => {
                    e.stopPropagation();
                    addEntryBelow(index, false);
                });
                
                // Add CC Below button
                div.querySelector('.btn-cc-below').addEventListener('click', (e) => {
                    e.stopPropagation();
                    addEntryBelow(index, true);
                });
                
                // Save button
                div.querySelector('.btn-save').addEventListener('click', (e) => {
                    e.stopPropagation();
                    saveEntryChanges(index);
                });
                
                // Delete button
                div.querySelector('.btn-delete').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteEntry(index);
                });
                
                previewList.appendChild(div);
            });

            document.getElementById('previewSection').classList.remove('hidden');
            // Only scroll to preview on initial display, not on toggle updates
            if (!skipScroll) {
                document.getElementById('previewSection').scrollIntoView({ behavior: 'smooth' });
            }
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', closeAllDropdowns);
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function selectEntry(index) {
            // Save previous entry if one was selected
            if (selectedEntryIndex !== null && selectedEntryIndex !== index) {
                saveEntryChanges(selectedEntryIndex, true);
                deselectEntry(selectedEntryIndex);
            }
            
            // Toggle if clicking same entry
            if (selectedEntryIndex === index) {
                saveEntryChanges(index, true);
                deselectEntry(index);
                return;
            }
            
            selectedEntryIndex = index;
            const entryEl = document.querySelector(`[data-index="${index}"]`);
            if (!entryEl) return;
            
            entryEl.classList.add('selected');
            enableEditing(entryEl, index);
        }
        
        function deselectEntry(index) {
            const entryEl = document.querySelector(`[data-index="${index}"]`);
            if (!entryEl) return;
            
            entryEl.classList.remove('selected');
            disableEditing(entryEl, index);
            selectedEntryIndex = null;
            closeAllDropdowns();
        }
        
        function enableEditing(entryEl, index) {
            const entry = processedData[index];
            
            // Replace text display with textarea
            const textContainer = entryEl.querySelector('.dialogue-text-container');
            textContainer.innerHTML = `<textarea class="edit-text-input">${entry.text}</textarea>`;
            
            // Replace timing display with editable inputs
            const timingContainer = entryEl.querySelector('.timing-display');
            const fps = getFramerate();
            const formatLabel = fps === null ? 'HH:MM:SS' : (fps > 60 ? 'HH:MM:SS:FFF' : 'HH:MM:SS:FF');
            const inputWidth = fps === null ? '80px' : '100px';
            
            timingContainer.innerHTML = `
                <div class="timing-input-group">
                    <span class="timing-format-label">${formatLabel}</span>
                    <input type="text" class="edit-timing-input edit-timing-start" style="width: ${inputWidth}" value="${formatEditableTimecode(entry.startSeconds)}" />
                </div>
                <span class="timing-separator">-</span>
                <div class="timing-input-group">
                    <span class="timing-format-label">${formatLabel}</span>
                    <input type="text" class="edit-timing-input edit-timing-end" style="width: ${inputWidth}" value="${formatEditableTimecode(entry.endSeconds)}" />
                </div>
            `;
            
            // Setup enhanced timing input behavior for both start and end inputs
            const startInput = timingContainer.querySelector('.edit-timing-start');
            const endInput = timingContainer.querySelector('.edit-timing-end');
            
            setupTimingInput(startInput, () => validateTimingPair(startInput, endInput));
            setupTimingInput(endInput, () => validateTimingPair(startInput, endInput));
            
            // Initial validation
            validateTimingPair(startInput, endInput);
        }
        
        // Validate timing pair and highlight if invalid
        function validateTimingPair(startInput, endInput) {
            const startSeconds = parseEditableTimecode(startInput.value);
            const endSeconds = parseEditableTimecode(endInput.value);
            
            if (endSeconds <= startSeconds) {
                startInput.classList.add('invalid');
                endInput.classList.add('invalid');
            } else {
                startInput.classList.remove('invalid');
                endInput.classList.remove('invalid');
            }
        }
        
        // Setup sequencer-like input behavior for timing inputs (dynamic format based on framerate)
        function setupTimingInput(input, onChangeCallback) {
            const fps = getFramerate();
            const hasFrames = fps !== null;
            const frameDigits = hasFrames ? (fps > 60 ? 3 : 2) : 0;
            const maxFieldIndex = hasFrames ? 3 : 2; // 3 or 4 fields
            
            // STATE: Track which field is being edited and digit position within field
            let activeFieldIndex = 0;  // 0=hours, 1=minutes, 2=seconds, 3=frames (if enabled)
            let digitPosition = 0;     // Current digit position within the field
            let pendingDigits = '';    // Accumulated digits for current field
            
            // Field selection ranges - dynamic based on framerate
            const ranges = hasFrames 
                ? (frameDigits === 3 
                    ? [[0, 2], [3, 5], [6, 8], [9, 12]]   // HH:MM:SS:FFF
                    : [[0, 2], [3, 5], [6, 8], [9, 11]])  // HH:MM:SS:FF
                : [[0, 2], [3, 5], [6, 8]];               // HH:MM:SS
            
            // Helper to select a specific field
            function selectField(fieldIndex) {
                if (fieldIndex > maxFieldIndex) fieldIndex = maxFieldIndex;
                const [start, end] = ranges[fieldIndex];
                input.setSelectionRange(start, end);
                activeFieldIndex = fieldIndex;
                digitPosition = 0;  // Reset digit position when field is selected
                pendingDigits = ''; // Clear pending digits
            }
            
            // Get field index from cursor position (for clicks)
            function getFieldFromPosition(pos) {
                if (pos <= 2) return 0;  // Hours (0-2)
                if (pos <= 5) return 1;  // Minutes (3-5)
                if (pos <= 8) return 2;  // Seconds (6-8)
                if (hasFrames) return 3; // Frames
                return 2; // No frames, stay on seconds
            }
            
            // Parse current value into array [hours, minutes, seconds, frames?]
            function parseValue(value) {
                const parts = value.split(':');
                const result = [
                    (parts[0] || '00').padStart(2, '0'),
                    (parts[1] || '00').padStart(2, '0'),
                    (parts[2] || '00').padStart(2, '0')
                ];
                if (hasFrames) {
                    result.push((parts[3] || '0'.repeat(frameDigits)).padStart(frameDigits, '0'));
                }
                return result;
            }
            
            // Format array back to timecode string
            function formatValue(parts) {
                let result = `${parts[0].padStart(2, '0')}:${parts[1].padStart(2, '0')}:${parts[2].padStart(2, '0')}`;
                if (hasFrames && parts[3]) {
                    result += `:${parts[3].padStart(frameDigits, '0')}`;
                }
                return result;
            }
            
            // Get max value for a field
            function _getMaxValue(fieldIndex) {
                if (fieldIndex === 1 || fieldIndex === 2) return 59; // Minutes/Seconds
                if (fieldIndex === 3 && hasFrames) {
                    return Math.ceil(fps) - 1; // Max frame is fps - 1
                }
                return 99; // Hours
            }
            
            // Get number of digits for a field
            function _getFieldDigits(fieldIndex) {
                if (fieldIndex === 3 && hasFrames) return frameDigits;
                return 2;
            }
            
            input.addEventListener('keydown', (e) => {
                // Allow tab to move to next input
                if (e.key === 'Tab') {
                    digitPosition = 0;
                    pendingDigits = '';
                    return;
                }
                
                // Allow Ctrl/Cmd shortcuts
                if (e.ctrlKey || e.metaKey) {
                    return;
                }
                
                // Arrow left - move to previous field
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    if (activeFieldIndex > 0) {
                        selectField(activeFieldIndex - 1);
                    }
                    return;
                }
                
                // Arrow right - move to next field
                if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    if (activeFieldIndex < 3) {
                        selectField(activeFieldIndex + 1);
                    }
                    return;
                }
                
                // Arrow up - increment current field
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    const parts = parseValue(input.value);
                    let val = parseInt(parts[activeFieldIndex]);
                    const maxVal = getMaxValue(activeFieldIndex);
                    val = Math.min(val + 1, maxVal);
                    parts[activeFieldIndex] = String(val).padStart(2, '0');
                    input.value = formatValue(parts);
                    selectField(activeFieldIndex);
                    if (onChangeCallback) onChangeCallback();
                    return;
                }
                
                // Arrow down - decrement current field
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const parts = parseValue(input.value);
                    let val = parseInt(parts[activeFieldIndex]);
                    val = Math.max(val - 1, 0);
                    parts[activeFieldIndex] = String(val).padStart(2, '0');
                    input.value = formatValue(parts);
                    selectField(activeFieldIndex);
                    if (onChangeCallback) onChangeCallback();
                    return;
                }
                
                // Home - select hours
                if (e.key === 'Home') {
                    e.preventDefault();
                    selectField(0);
                    return;
                }
                
                // End - select last field
                if (e.key === 'End') {
                    e.preventDefault();
                    selectField(maxFieldIndex);
                    return;
                }
                
                const parts = parseValue(input.value);
                
                // Backspace - delete one digit at a time
                if (e.key === 'Backspace' || e.key === 'Delete') {
                    e.preventDefault();
                    
                    // If we were in the middle of entering digits, just clear and stay on this field
                    if (digitPosition > 0) {
                        const zeroVal = _getFieldDigits(activeFieldIndex) === 3 ? '000' : '00';
                        parts[activeFieldIndex] = zeroVal;
                        input.value = formatValue(parts);
                        digitPosition = 0;
                        pendingDigits = '';
                        selectField(activeFieldIndex);
                        if (onChangeCallback) onChangeCallback();
                        return;
                    }
                    
                    // Check if already zero before attempting deletion
                    const zeroVal = _getFieldDigits(activeFieldIndex) === 3 ? '000' : '00';
                    const wasAlreadyZero = parts[activeFieldIndex] === zeroVal;
                    
                    if (wasAlreadyZero && activeFieldIndex > 0) {
                        // Already at zero, move to previous field
                        selectField(activeFieldIndex - 1);
                    } else if (!wasAlreadyZero) {
                        // Shift digits right (remove rightmost, pad left with 0)
                        const currentValue = parts[activeFieldIndex];
                        const shifted = '0' + currentValue.slice(0, -1);
                        parts[activeFieldIndex] = shifted;
                        
                        input.value = formatValue(parts);
                        if (onChangeCallback) onChangeCallback();
                        
                        // Check if we just made it zero - move to previous field
                        if (parts[activeFieldIndex] === zeroVal && activeFieldIndex > 0) {
                            selectField(activeFieldIndex - 1);
                        } else {
                            selectField(activeFieldIndex);
                        }
                    } else {
                        // Already zero but on first field (hours), just stay
                        selectField(activeFieldIndex);
                    }
                    return;
                }
                
                // Handle digit input
                if (/[0-9]/.test(e.key)) {
                    e.preventDefault();
                    
                    const maxDigits = _getFieldDigits(activeFieldIndex);
                    let fieldValue;
                    let shouldAdvance = false;
                    
                    // Add digit to pending
                    pendingDigits += e.key;
                    digitPosition++;
                    
                    if (digitPosition < maxDigits) {
                        // Still building the field value
                        fieldValue = pendingDigits.padStart(maxDigits, '0');
                    } else {
                        // Field is complete
                        fieldValue = pendingDigits.slice(-maxDigits); // Take last N digits
                        const val = parseInt(fieldValue);
                        const maxVal = _getMaxValue(activeFieldIndex);
                        
                        // Block invalid values
                        if (val > maxVal) {
                            // Invalid input - revert to previous digits minus last
                            pendingDigits = pendingDigits.slice(0, -1);
                            digitPosition--;
                            return;
                        }
                        
                        shouldAdvance = true;
                    }
                    
                    parts[activeFieldIndex] = fieldValue;
                    input.value = formatValue(parts);
                    if (onChangeCallback) onChangeCallback();
                    
                    // Auto-advance to next field if appropriate
                    if (shouldAdvance && activeFieldIndex < maxFieldIndex) {
                        selectField(activeFieldIndex + 1);
                    } else if (shouldAdvance) {
                        // On last field after completing digits, re-select it
                        selectField(activeFieldIndex);
                    } else {
                        // Still entering digits, position cursor BEFORE the next digit slot
                        const [start, end] = ranges[activeFieldIndex];
                        // Position cursor at the next digit to be entered
                        const cursorPos = start + digitPosition;
                        input.setSelectionRange(cursorPos, cursorPos);
                    }
                    return;
                }
                
                // Block all other keys
                e.preventDefault();
            });
            
            // Click to select the field that was clicked
            input.addEventListener('click', (e) => {
                const field = getFieldFromPosition(e.target.selectionStart);
                selectField(field);
            });
            
            // Focus to select hours by default
            input.addEventListener('focus', (e) => {
                selectField(0);
            });
            
            // Prevent pasting
            input.addEventListener('paste', (e) => {
                e.preventDefault();
            });
        }
        
        function disableEditing(entryEl, index) {
            const entry = processedData[index];
            
            // Restore text display
            const textContainer = entryEl.querySelector('.dialogue-text-container');
            textContainer.innerHTML = `<p class="dialogue-text-display">${escapeHtml(entry.text)}</p>`;
            
            // Restore timing display
            const timingContainer = entryEl.querySelector('.timing-display');
            timingContainer.innerHTML = `<span class="text-xs text-slate-500">${entry.timecode}</span>`;
        }
        
        // Get framerate based on current mode's file(s)
        // Returns null if "ignore", otherwise returns fps number
        function getFramerate() {
            if (currentMode === 'edit') {
                const editFileEl = document.getElementById('file-edit');
                const select = editFileEl?.querySelector('.framerate-select');
                const customInput = editFileEl?.querySelector('.framerate-custom');
                const val = select?.value || 'ignore';
                if (val === 'ignore') return null;
                if (val === 'custom') {
                    const customVal = parseFloat(customInput?.value);
                    return customVal > 0 ? customVal : null;
                }
                return parseFloat(val);
            } else if (currentMode === 'merge') {
                // Use first file's framerate (or could use most common)
                const firstFile = mergeFiles[0];
                const val = firstFile?.framerate || 'ignore';
                return val === 'ignore' ? null : parseFloat(val);
            } else if (currentMode === 'sequence') {
                // Use first file's framerate
                const firstFile = sequenceFiles[0];
                const val = firstFile?.framerate || 'ignore';
                return val === 'ignore' ? null : parseFloat(val);
            }
            return null; // Default: ignore frames
        }
        
        // Get number of digits for frame display based on framerate
        function getFrameDigits(fps) {
            if (fps === null) return 0; // No frames
            return fps > 60 ? 3 : 2; // 3 digits for high framerates, 2 for standard
        }
        
        function formatEditableTimecode(seconds) {
            const fps = getFramerate();
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            
            if (fps === null) {
                // No frames - just HH:MM:SS
                return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
            }
            
            const ff = Math.floor((seconds % 1) * fps);
            const frameDigits = getFrameDigits(fps);
            return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}:${String(ff).padStart(frameDigits,'0')}`;
        }
        
        function parseEditableTimecode(timecodeStr) {
            const fps = getFramerate();
            const parts = timecodeStr.split(':').map(Number);
            
            if (fps === null || parts.length === 3) {
                // No frames - just HH:MM:SS
                if (parts.length >= 3) {
                    return parts[0] * 3600 + parts[1] * 60 + parts[2];
                }
            } else if (parts.length === 4) {
                return parts[0] * 3600 + parts[1] * 60 + parts[2] + parts[3] / fps;
            }
            return 0;
        }
        
        function toggleSpeakerDropdown(index, speakerBtn) {
            const container = speakerBtn.closest('.speaker-name-container');
            const existingDropdown = container.querySelector('.speaker-dropdown');
            
            if (existingDropdown) {
                existingDropdown.remove();
                openDropdownIndex = null;
                return;
            }
            
            closeAllDropdowns();
            
            // Get unique speakers
            const speakers = [...new Set(processedData.map(e => e.speaker))];
            const currentSpeaker = processedData[index].speaker;
            
            const dropdown = document.createElement('div');
            dropdown.className = 'speaker-dropdown';
            dropdown.innerHTML = `
                ${speakers.map(s => `
                    <div class="speaker-option ${s === currentSpeaker ? 'selected' : ''}" data-speaker="${escapeHtml(s)}">${escapeHtml(s)}</div>
                `).join('')}
                <div class="speaker-option custom-option" data-custom="true">+ Custom Speaker...</div>
                <div class="speaker-option rename-option" data-rename="true"> Rename "${escapeHtml(currentSpeaker)}" (All)</div>
            `;
            
            // Add click handlers for speaker options
            dropdown.querySelectorAll('.speaker-option:not(.custom-option):not(.rename-option)').forEach(opt => {
                opt.addEventListener('click', (e) => {
                    e.stopPropagation();
                    setSpeaker(index, opt.dataset.speaker);
                    closeAllDropdowns();
                });
            });
            
            // Custom speaker option
            dropdown.querySelector('.custom-option').addEventListener('click', (e) => {
                e.stopPropagation();
                showCustomSpeakerInput(dropdown, index);
            });
            
            // Rename speaker option
            dropdown.querySelector('.rename-option').addEventListener('click', (e) => {
                e.stopPropagation();
                showRenameSpeakerInput(dropdown, index, currentSpeaker);
            });
            
            container.appendChild(dropdown);
            openDropdownIndex = index;
        }
        
        function showCustomSpeakerInput(dropdown, index) {
            const customOption = dropdown.querySelector('.custom-option');
            customOption.remove();
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'speaker-custom-input';
            input.placeholder = 'Enter speaker name...';
            dropdown.appendChild(input);
            input.focus();
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && input.value.trim()) {
                    setSpeaker(index, input.value.trim());
                    closeAllDropdowns();
                }
                if (e.key === 'Escape') {
                    closeAllDropdowns();
                }
            });
            
            input.addEventListener('click', (e) => e.stopPropagation());
        }
        
        function showRenameSpeakerInput(dropdown, index, oldSpeaker) {
            // Remove the rename option and custom option, show input
            const renameOption = dropdown.querySelector('.rename-option');
            const customOption = dropdown.querySelector('.custom-option');
            if (renameOption) renameOption.remove();
            if (customOption) customOption.remove();
            
            const inputContainer = document.createElement('div');
            inputContainer.style.cssText = 'padding: 8px 10px; border-top: 1px solid #475569;';
            inputContainer.innerHTML = `
                <div style="color: #fbbf24; font-size: 0.75rem; margin-bottom: 6px;">Rename all "${escapeHtml(oldSpeaker)}" to:</div>
            `;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'speaker-custom-input';
            input.style.cssText = 'margin-top: 0; border-top: none;';
            input.placeholder = 'Enter new name...';
            input.value = oldSpeaker === '[CC]' ? '' : oldSpeaker; // Pre-fill with current name for easy editing
            inputContainer.appendChild(input);
            dropdown.appendChild(inputContainer);
            input.focus();
            input.select();
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && input.value.trim()) {
                    renameSpeaker(oldSpeaker, input.value.trim());
                    closeAllDropdowns();
                }
                if (e.key === 'Escape') {
                    closeAllDropdowns();
                }
            });
            
            input.addEventListener('click', (e) => e.stopPropagation());
        }
        
        function renameSpeaker(oldSpeaker, newSpeaker) {
            if (oldSpeaker === newSpeaker) return;
            
            let changedCount = 0;
            
            // Update all entries with the old speaker name
            processedData.forEach((entry, idx) => {
                if (entry.speaker === oldSpeaker) {
                    entry.speaker = newSpeaker;
                    changedCount++;
                    
                    // Update the DOM element if it exists
                    const entryEl = document.querySelector(`[data-index="${idx}"]`);
                    if (entryEl) {
                        const speakerBtn = entryEl.querySelector('.speaker-name-btn');
                        if (speakerBtn) {
                            speakerBtn.textContent = newSpeaker;
                        }
                        
                        // Update CC indicator
                        const isCC = newSpeaker === '[CC]';
                        const existingIndicator = entryEl.querySelector('.cc-indicator');
                        if (isCC && !existingIndicator) {
                            speakerBtn.insertAdjacentHTML('afterend', '<span class="cc-indicator">CC</span>');
                        } else if (!isCC && existingIndicator) {
                            existingIndicator.remove();
                        }
                    }
                }
            });
            
            // Update stats - exclude [CC] from speaker count
            const speakerSet = new Set(processedData.filter(e => e.speaker !== '[CC]').map(e => e.speaker));
            document.getElementById('statSpeakers').textContent = speakerSet.size;
            
            console.log(`Renamed "${oldSpeaker}" to "${newSpeaker}" in ${changedCount} entries.`);
        }
        
        function setSpeaker(index, speaker) {
            processedData[index].speaker = speaker;
            const entryEl = document.querySelector(`[data-index="${index}"]`);
            if (entryEl) {
                const speakerBtn = entryEl.querySelector('.speaker-name-btn');
                speakerBtn.textContent = speaker;
                
                // Update CC indicator
                const isCC = speaker === '[CC]';
                const existingIndicator = entryEl.querySelector('.cc-indicator');
                if (isCC && !existingIndicator) {
                    speakerBtn.insertAdjacentHTML('afterend', '<span class="cc-indicator">CC</span>');
                } else if (!isCC && existingIndicator) {
                    existingIndicator.remove();
                }
            }
            
            // Update stats - exclude [CC] from speaker count
            const speakerSet = new Set(processedData.filter(e => e.speaker !== '[CC]').map(e => e.speaker));
            document.getElementById('statSpeakers').textContent = speakerSet.size;
        }
        
        function closeAllDropdowns() {
            document.querySelectorAll('.speaker-dropdown').forEach(d => d.remove());
            openDropdownIndex = null;
        }
        
        function addEntryAbove(index, isCC = false) {
            const refEntry = processedData[index];
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 1.0;
            const desiredDuration = Math.max(minDuration, 1.0); // At least 1 second for new entry
            
            // Check available gap
            let availableGap = refEntry.startSeconds; // Default: from start of timeline
            let prevEntry = null;
            
            if (index > 0) {
                prevEntry = processedData[index - 1];
                availableGap = refEntry.startSeconds - prevEntry.endSeconds;
            }
            
            let startTime, endTime;
            
            if (availableGap >= desiredDuration) {
                // Enough gap - place just before reference entry
                endTime = refEntry.startSeconds;
                startTime = endTime - Math.min(availableGap, desiredDuration);
            } else {
                // Not enough gap - need to nudge surrounding entries
                const neededTime = desiredDuration - Math.max(0, availableGap);
                
                // Split the nudge equally between prev entry (shorten end) and ref entry (shift start forward)
                let nudgePrev = 0;
                let nudgeRef = 0;
                
                if (prevEntry && index > 0) {
                    // Can we shorten the previous entry's end?
                    const prevDuration = prevEntry.endSeconds - prevEntry.startSeconds;
                    const prevCanGive = Math.max(0, prevDuration - minDuration);
                    
                    // Can we push the reference entry's start later?
                    const refDuration = refEntry.endSeconds - refEntry.startSeconds;
                    const refCanGive = Math.max(0, refDuration - minDuration);
                    
                    // Split needed time equally, but respect limits
                    const halfNeeded = neededTime / 2;
                    nudgePrev = Math.min(halfNeeded, prevCanGive);
                    nudgeRef = Math.min(halfNeeded, refCanGive);
                    
                    // If one side can't give enough, try to take more from the other
                    if (nudgePrev < halfNeeded && nudgeRef < refCanGive) {
                        nudgeRef = Math.min(neededTime - nudgePrev, refCanGive);
                    } else if (nudgeRef < halfNeeded && nudgePrev < prevCanGive) {
                        nudgePrev = Math.min(neededTime - nudgeRef, prevCanGive);
                    }
                    
                    // Apply nudges to surrounding entries
                    if (nudgePrev > 0) {
                        prevEntry.endSeconds -= nudgePrev;
                        prevEntry.timecode = `[${formatTimecode(prevEntry.startSeconds)} - ${formatTimecode(prevEntry.endSeconds)}]`;
                    }
                    if (nudgeRef > 0) {
                        refEntry.startSeconds += nudgeRef;
                        refEntry.timecode = `[${formatTimecode(refEntry.startSeconds)} - ${formatTimecode(refEntry.endSeconds)}]`;
                    }
                } else {
                    // No previous entry - only nudge the reference entry forward
                    const refDuration = refEntry.endSeconds - refEntry.startSeconds;
                    const refCanGive = Math.max(0, refDuration - minDuration);
                    nudgeRef = Math.min(neededTime, refCanGive);
                    
                    if (nudgeRef > 0) {
                        refEntry.startSeconds += nudgeRef;
                        refEntry.timecode = `[${formatTimecode(refEntry.startSeconds)} - ${formatTimecode(refEntry.endSeconds)}]`;
                    }
                }
                
                // Calculate new entry timing after nudges
                startTime = prevEntry ? prevEntry.endSeconds : Math.max(0, refEntry.startSeconds - desiredDuration);
                endTime = refEntry.startSeconds;
                
                // Ensure we still have at least minimum duration
                if (endTime - startTime < minDuration) {
                    startTime = Math.max(0, endTime - minDuration);
                }
            }
            
            const newEntry = {
                startSeconds: startTime,
                endSeconds: endTime,
                timecode: `[${formatTimecode(startTime)} - ${formatTimecode(endTime)}]`,
                speaker: isCC ? '[CC]' : refEntry.speaker,
                text: isCC ? '(Enter description)' : 'New dialogue'
            };
            
            processedData.splice(index, 0, newEntry);
            selectedEntryIndex = null;
            displayPreview();
            
            // Select the new entry for immediate editing
            setTimeout(() => selectEntry(index), 50);
        }
        
        function addEntryBelow(index, isCC = false) {
            const refEntry = processedData[index];
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 1.0;
            const desiredDuration = Math.max(minDuration, 1.0); // At least 1 second for new entry
            
            // Check available gap
            let availableGap = Infinity; // Default: no limit (end of timeline)
            let nextEntry = null;
            
            if (index < processedData.length - 1) {
                nextEntry = processedData[index + 1];
                availableGap = nextEntry.startSeconds - refEntry.endSeconds;
            }
            
            let startTime, endTime;
            
            if (availableGap >= desiredDuration) {
                // Enough gap - place just after reference entry
                startTime = refEntry.endSeconds;
                endTime = startTime + Math.min(availableGap === Infinity ? desiredDuration : availableGap, desiredDuration);
            } else {
                // Not enough gap - need to nudge surrounding entries
                const neededTime = desiredDuration - Math.max(0, availableGap);
                
                // Split the nudge equally between ref entry (shorten end) and next entry (shift start later)
                let nudgeRef = 0;
                let nudgeNext = 0;
                
                if (nextEntry) {
                    // Can we shorten the reference entry's end?
                    const refDuration = refEntry.endSeconds - refEntry.startSeconds;
                    const refCanGive = Math.max(0, refDuration - minDuration);
                    
                    // Can we push the next entry's start later?
                    const nextDuration = nextEntry.endSeconds - nextEntry.startSeconds;
                    const nextCanGive = Math.max(0, nextDuration - minDuration);
                    
                    // Split needed time equally, but respect limits
                    const halfNeeded = neededTime / 2;
                    nudgeRef = Math.min(halfNeeded, refCanGive);
                    nudgeNext = Math.min(halfNeeded, nextCanGive);
                    
                    // If one side can't give enough, try to take more from the other
                    if (nudgeRef < halfNeeded && nudgeNext < nextCanGive) {
                        nudgeNext = Math.min(neededTime - nudgeRef, nextCanGive);
                    } else if (nudgeNext < halfNeeded && nudgeRef < refCanGive) {
                        nudgeRef = Math.min(neededTime - nudgeNext, refCanGive);
                    }
                    
                    // Apply nudges to surrounding entries
                    if (nudgeRef > 0) {
                        refEntry.endSeconds -= nudgeRef;
                        refEntry.timecode = `[${formatTimecode(refEntry.startSeconds)} - ${formatTimecode(refEntry.endSeconds)}]`;
                    }
                    if (nudgeNext > 0) {
                        nextEntry.startSeconds += nudgeNext;
                        nextEntry.timecode = `[${formatTimecode(nextEntry.startSeconds)} - ${formatTimecode(nextEntry.endSeconds)}]`;
                    }
                } else {
                    // No next entry - only nudge the reference entry's end back
                    const refDuration = refEntry.endSeconds - refEntry.startSeconds;
                    const refCanGive = Math.max(0, refDuration - minDuration);
                    nudgeRef = Math.min(neededTime, refCanGive);
                    
                    if (nudgeRef > 0) {
                        refEntry.endSeconds -= nudgeRef;
                        refEntry.timecode = `[${formatTimecode(refEntry.startSeconds)} - ${formatTimecode(refEntry.endSeconds)}]`;
                    }
                }
                
                // Calculate new entry timing after nudges
                startTime = refEntry.endSeconds;
                endTime = nextEntry ? nextEntry.startSeconds : startTime + desiredDuration;
                
                // Ensure we still have at least minimum duration
                if (endTime - startTime < minDuration) {
                    endTime = startTime + minDuration;
                }
            }
            
            const newEntry = {
                startSeconds: startTime,
                endSeconds: endTime,
                timecode: `[${formatTimecode(startTime)} - ${formatTimecode(endTime)}]`,
                speaker: isCC ? '[CC]' : refEntry.speaker,
                text: isCC ? '(Enter description)' : 'New dialogue'
            };
            
            processedData.splice(index + 1, 0, newEntry);
            selectedEntryIndex = null;
            displayPreview();
            
            // Select the new entry for immediate editing
            setTimeout(() => selectEntry(index + 1), 50);
        }
        
        function deleteEntry(index) {
            if (processedData.length <= 1) {
                alert("Cannot delete the last entry.");
                return;
            }
            
            // Remove the entry
            processedData.splice(index, 1);
            selectedEntryIndex = null;
            
            // Re-render the preview
            displayPreview();
            
            // Update entry count display
            document.getElementById('entryCount').textContent = processedData.length;
        }
        
        function saveEntryChanges(index, silent = false) {
            const entryEl = document.querySelector(`[data-index="${index}"]`);
            if (!entryEl) return;
            
            const entry = processedData[index];
            const originalStartSeconds = entry.startSeconds;
            
            // Get edited text
            const textInput = entryEl.querySelector('.edit-text-input');
            if (textInput) {
                entry.text = textInput.value;
            }
            
            // Get edited timing
            const startInput = entryEl.querySelector('.edit-timing-start');
            const endInput = entryEl.querySelector('.edit-timing-end');
            let timingChanged = false;
            if (startInput && endInput) {
                const newStartSeconds = parseEditableTimecode(startInput.value);
                const newEndSeconds = parseEditableTimecode(endInput.value);
                
                if (newStartSeconds !== entry.startSeconds || newEndSeconds !== entry.endSeconds) {
                    timingChanged = true;
                }
                
                entry.startSeconds = newStartSeconds;
                entry.endSeconds = newEndSeconds;
                entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
            }
            
            // Update stats
            document.getElementById('statEntries').textContent = processedData.length;
            
            // Calculate duration based on mode
            let durationMinutes = 0;
            if (previewMode === 'sequence') {
                let totalSeconds = 0;
                sequenceFiles.forEach(f => {
                    totalSeconds += parseDuration(f.duration);
                });
                durationMinutes = Math.floor(totalSeconds / 60);
            } else {
                const lastEntry = processedData[processedData.length - 1];
                durationMinutes = lastEntry ? Math.floor(lastEntry.endSeconds / 60) : 0;
            }
            document.getElementById('statDuration').textContent = durationMinutes + 'm';
            
            // If timing changed, re-sort entries by start time and refresh preview
            if (timingChanged) {
                selectedEntryIndex = null;
                processedData.sort((a, b) => a.startSeconds - b.startSeconds);
                displayPreview();
                return; // displayPreview handles everything, no need to deselect
            }
            
            if (!silent) {
                deselectEntry(index);
            }
        }

        // EXPORTS
        function download(content, filename, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        document.getElementById('downloadTxtBtn').addEventListener('click', () => {
            if (!processedData) return;
            const showSpeakers = document.getElementById('toggleSpeakerNames').checked;
            const showCC = document.getElementById('toggleCC').checked;
            const stripSilence = document.getElementById('toggleStripSilence').checked;
            
            // STEP 1: Strip (Silence) entries if enabled
            const isSilence = (entry) => /^\(\s*silence\s*\)$/i.test(entry.text.trim());
            const noSilenceData = stripSilence ? processedData.filter(e => !isSilence(e)) : processedData;
            
            // STEP 2: Filter out CC entries if CC toggle is off
            const isCC = (entry) => entry.speaker === '[CC]' || (entry.text.startsWith('(') && entry.text.endsWith(')'));
            const filteredData = showCC ? noSilenceData : noSilenceData.filter(e => !isCC(e));
            
            // STEP 3: Clone and apply timing corrections (linearization + min duration)
            const txtData = filteredData.map(entry => ({ ...entry }));
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 0;
            
            let lastEnd = 0;
            txtData.forEach((entry) => {
                // Fix overlaps
                if (entry.startSeconds < lastEnd) {
                    entry.startSeconds = lastEnd;
                }
                // Apply minimum duration
                if (minDuration > 0) {
                    const currentDuration = entry.endSeconds - entry.startSeconds;
                    if (currentDuration < minDuration) {
                        entry.endSeconds = entry.startSeconds + minDuration;
                    }
                } else {
                    if (entry.startSeconds >= entry.endSeconds) {
                        entry.endSeconds = entry.startSeconds + 0.1;
                    }
                }
                // Update timecode string
                entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
                lastEnd = entry.endSeconds;
            });
            
            let content = '';
            txtData.forEach(entry => {
                content += `${entry.timecode}\n`;
                if (showSpeakers) {
                    content += `${entry.speaker}\n`;
                }
                content += `${entry.text}\n\n`;
            });
            const fileName = document.getElementById('exportFileName').value.trim() || 'merged_transcript';
            download(content, `${fileName}.txt`, 'text/plain');
        });

        document.getElementById('downloadSrtBtn').addEventListener('click', () => {
            if (!processedData) return;
            const showSpeakers = document.getElementById('toggleSpeakerNames').checked;
            const showCC = document.getElementById('toggleCC').checked;
            const stripSilence = document.getElementById('toggleStripSilence').checked;
            
            // SRT COMPLIANCE FIX: Linearize (No Overlaps)
            // Option A: Keep end times fixed, recalculate starts
            // If Line B overlaps Line A, Line B starts when Line A ends.
            // Ensure minimum display duration so entries don't get compressed to nothing.
            
            // STEP 1: Strip (Silence) entries if enabled - frees up timing space
            const isSilence = (entry) => /^\(\s*silence\s*\)$/i.test(entry.text.trim());
            const noSilenceData = stripSilence ? processedData.filter(e => !isSilence(e)) : processedData;
            
            // STEP 2: Filter out CC entries if CC toggle is off
            const isCC = (entry) => entry.speaker === '[CC]' || (entry.text.startsWith('(') && entry.text.endsWith(')'));
            const filteredData = showCC ? noSilenceData : noSilenceData.filter(e => !isCC(e));
            
            const srtData = filteredData.map(entry => ({ ...entry }));
            
            // User-configurable minimum duration (0 = off, only fix overlaps)
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 0;
            
            let lastEnd = 0;
            srtData.forEach((entry, index) => {
                // Force Start to be at least the previous End (fix overlaps)
                if (entry.startSeconds < lastEnd) {
                    entry.startSeconds = lastEnd;
                }
                
                // Apply minimum duration if enabled
                if (minDuration > 0) {
                    const currentDuration = entry.endSeconds - entry.startSeconds;
                    if (currentDuration < minDuration) {
                        entry.endSeconds = entry.startSeconds + minDuration;
                    }
                } else {
                    // Even with minDuration off, ensure valid timing (start < end)
                    if (entry.startSeconds >= entry.endSeconds) {
                        entry.endSeconds = entry.startSeconds + 0.1; // Tiny buffer
                    }
                }
                
                lastEnd = entry.endSeconds;
            });

            let content = '';
            const formatSrtTime = (ms) => {
                const h = Math.floor(ms / 3600000);
                const m = Math.floor((ms % 3600000) / 60000);
                const s = Math.floor((ms % 60000) / 1000);
                const mil = Math.floor(ms % 1000);
                return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')},${String(mil).padStart(3,'0')}`;
            };
            
            let counter = 1;
            srtData.forEach((entry) => {
                // Note: CC entries already filtered above if showCC is false
                const entryIsCC = entry.speaker === '[CC]' || (entry.text.startsWith('(') && entry.text.endsWith(')'));
                
                const startMs = entry.startSeconds * 1000;
                const endMs = entry.endSeconds * 1000;
                content += `${counter++}\n${formatSrtTime(startMs)} --> ${formatSrtTime(endMs)}\n`;
                
                if (showSpeakers && !entryIsCC) { // Don't show speaker name for CC lines in SRT
                     content += `${entry.speaker}: `;
                }
                content += `${entry.text}\n\n`;
            });
            const fileName = document.getElementById('exportFileName').value.trim() || 'merged_transcript';
            download(content, `${fileName}.srt`, 'text/plain');
        });

        document.getElementById('copyBtn').addEventListener('click', () => {
            if (!processedData) return;
            const showSpeakers = document.getElementById('toggleSpeakerNames').checked;
            const showCC = document.getElementById('toggleCC').checked;
            const stripSilence = document.getElementById('toggleStripSilence').checked;
            
            // STEP 1: Strip (Silence) entries if enabled
            const isSilence = (entry) => /^\(\s*silence\s*\)$/i.test(entry.text.trim());
            const noSilenceData = stripSilence ? processedData.filter(e => !isSilence(e)) : processedData;
            
            // STEP 2: Filter out CC entries if CC toggle is off
            const isCC = (entry) => entry.speaker === '[CC]' || (entry.text.startsWith('(') && entry.text.endsWith(')'));
            const filteredData = showCC ? noSilenceData : noSilenceData.filter(e => !isCC(e));
            
            // STEP 3: Clone and apply timing corrections (linearization + min duration)
            const copyData = filteredData.map(entry => ({ ...entry }));
            const minDuration = parseFloat(document.getElementById('settingMinDuration').value) || 0;
            
            let lastEnd = 0;
            copyData.forEach((entry) => {
                // Fix overlaps
                if (entry.startSeconds < lastEnd) {
                    entry.startSeconds = lastEnd;
                }
                // Apply minimum duration
                if (minDuration > 0) {
                    const currentDuration = entry.endSeconds - entry.startSeconds;
                    if (currentDuration < minDuration) {
                        entry.endSeconds = entry.startSeconds + minDuration;
                    }
                } else {
                    if (entry.startSeconds >= entry.endSeconds) {
                        entry.endSeconds = entry.startSeconds + 0.1;
                    }
                }
                // Update timecode string
                entry.timecode = `[${formatTimecode(entry.startSeconds)} - ${formatTimecode(entry.endSeconds)}]`;
                lastEnd = entry.endSeconds;
            });
            
            let content = '';
            copyData.forEach(entry => {
                content += `${entry.timecode}\n`;
                if (showSpeakers) {
                    content += `${entry.speaker}\n`;
                }
                content += `${entry.text}\n\n`;
            });
            navigator.clipboard.writeText(content).then(() => {
                const originalText = document.getElementById('copyBtn').innerHTML;
                document.getElementById('copyBtn').innerHTML = `<span class="text-green-600 font-bold">Copied!</span>`;
                setTimeout(() => {
                    document.getElementById('copyBtn').innerHTML = originalText;
                }, 2000);
            });
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            editFile = null;
            mergeFiles = [];
            sequenceFiles = [];
            fileIdCounter = 0;
            processedData = null;
            previewMode = null; // Reset preview mode
            filesContainerEdit.innerHTML = '';
            filesContainerMerge.innerHTML = '';
            filesContainerSequence.innerHTML = '';
            document.getElementById('previewSection').classList.add('hidden');
            document.getElementById('previewList').innerHTML = '';
            document.getElementById('statEntries').textContent = '0';
            document.getElementById('statDuration').textContent = '0m';
            document.getElementById('statSpeakers').textContent = '0';
            
            // Reset to default state
            initEditFile();
            addMergeFile();
            addMergeFile();
            addSequenceFile();
            addSequenceFile();

            // Maintain current mode and blur button
            switchTab(currentMode);
            document.getElementById('clearBtn').blur();
        });

        document.getElementById('addTrackBtn').addEventListener('click', addMergeFile);
        document.getElementById('addPartBtn').addEventListener('click', addSequenceFile);
        processBtn.addEventListener('click', processTranscripts);

        // Toggle Listeners - skipScroll=true to prevent viewport jumping when adjusting settings
        document.getElementById('toggleSpeakerNames').addEventListener('change', () => displayPreview(true));
        document.getElementById('toggleCC').addEventListener('change', () => displayPreview(true));
        document.getElementById('toggleStripSilence').addEventListener('change', () => displayPreview(true));
        document.getElementById('toggleLimits').addEventListener('change', () => {
            if (processedData !== null) processTranscripts();
        });
        
        // Numeric input listeners - reprocess on change for live updates
        document.getElementById('settingCpl').addEventListener('input', () => {
            if (processedData !== null) processTranscripts();
        });
        document.getElementById('settingMaxLines').addEventListener('input', () => {
            if (processedData !== null) processTranscripts();
        });
        document.getElementById('settingMinDuration').addEventListener('input', () => {
            if (processedData !== null) displayPreview(true); // Min duration affects export, not processedData
        });

        // Init
        initEditFile();
        addMergeFile();
        addMergeFile();
        addSequenceFile();
        addSequenceFile();
    </script>
</body>
</html>